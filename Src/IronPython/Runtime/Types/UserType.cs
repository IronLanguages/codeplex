/* ****************************************************************************
 *
 * Copyright (c) Microsoft Corporation. 
 *
 * This source code is subject to terms and conditions of the Microsoft Permissive License. A 
 * copy of the license can be found in the License.html file at the root of this distribution. If 
 * you cannot locate the  Microsoft Permissive License, please send an email to 
 * dlr@microsoft.com. By using this source code in any fashion, you are agreeing to be bound 
 * by the terms of the Microsoft Permissive License.
 *
 * You must not remove this notice, or any other, from this software.
 *
 *
 * ***************************************************************************/

using System;
using System.Reflection;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Threading;

using Microsoft.Scripting;
using Microsoft.Scripting.Math;
using Microsoft.Scripting.Actions;
using Microsoft.Scripting.Utils;

using IronPython.Runtime.Calls;
using IronPython.Runtime.Operations;
using IronPython.Compiler.Generation;
using Microsoft.Scripting.Ast;

namespace IronPython.Runtime.Types {
    /// <summary>
    /// UserType represents the type of new-style Python classes (which can inherit from built-in types). 
    /// 
    /// Object instances of new-style Python classes are represented by classes generated by NewTypeMaker,
    /// and are named IronPython.NewTypes.someName.
    /// 
    /// OldClass is the equivalent of UserType for old-style Python classes (which cannot inherit from 
    /// built-in types).
    /// </summary>
    internal class UserTypeBuilder : ReflectedTypeBuilder {
        private string _name;
        private PythonTuple _bases;
        private IAttributesCollection _vars;
        private Type _type;
        private bool _hasDict, _hasWeakRef, _hasSlots, _hasFinalizer;
        private static Dictionary<Type, TypePrepender.PrependerState> _prependerState = new Dictionary<Type, TypePrepender.PrependerState>();

        private UserTypeBuilder(string name, PythonTuple bases, IAttributesCollection vars) {
            _name = name;
            _bases = bases;
            _vars = vars;
        }

        public static PythonType Build(CodeContext context, string name, PythonTuple bases, IAttributesCollection vars) {
            UserTypeBuilder utb = new UserTypeBuilder(name, bases, vars);
            Type type = NewTypeMaker.GetNewType(name, bases, vars);
            PythonTypeBuilder builder = new PythonTypeBuilder(name, type);

            utb.Builder = builder;
            utb._type = type;

            return utb.DoBuild(context);
        }

        public static void Build(CodeContext context, PythonType dt, string name, PythonTuple bases, IAttributesCollection vars) {
            Type type = NewTypeMaker.GetNewType(name, bases, vars);
            PythonTypeBuilder builder = PythonTypeBuilder.GetBuilder(dt);

            UserTypeBuilder utb = new UserTypeBuilder(name, bases, vars);
            utb.Builder = builder;
            utb._type = type;
            builder.SetName(name);

            utb.DoBuild(context);
        }

        /// <summary>
        /// TODO: This needs to become an IDynamicObject
        /// </summary>
        class TypePrepender : ICallableWithCodeContext, IFancyCallable {
            private PythonType _type;
            private PrependerState _state;

            public class PrependerState {
                public PrependerState(BuiltinFunction ctor) {
                    Ctor = ctor;
                }

                public BuiltinFunction Ctor;
                public FastDynamicSite<BuiltinFunction, PythonType, object[], object> Site;                
            }

            public TypePrepender(PythonType dt, PrependerState state) {
                _type = dt;
                _state = state;
            }

            #region ICallableWithCodeContext Members

            public object Call(CodeContext context, object[] args) {
                // we've already boxed the args so we'll just call through a splat-site
                // which will do the unsplat for us.
                if (_state.Site == null) {
                    CreateCallSite();
                }

                return _state.Site.Invoke(_state.Ctor, _type, args);
            }

            private void CreateCallSite() {
                _state.Site = FastDynamicSite<BuiltinFunction, PythonType, object[], object>.Create(
                    DefaultContext.Default,
                    CallAction.Make(
                        new CallSignature(
                            new ArgumentInfo(ArgumentKind.Simple),
                            new ArgumentInfo(ArgumentKind.List)
                        )
                    )
                );
            }

            #endregion

            #region IFancyCallable Members

            public object Call(CodeContext context, object[] args, string[] names) {
                return PythonCalls.CallWithKeywordArgs(_state.Ctor, ArrayUtils.Insert((object)_type, args), names);
            }

            #endregion
        }

        private PythonType DoBuild(CodeContext context) {
            Debug.Assert(Builder != null);

            Builder.SetTypeContext(context.LanguageContext.ContextId);

            TypePrepender.PrependerState prependerState;
            lock (_prependerState) {
                if (!_prependerState.TryGetValue(_type, out prependerState)) {
                    _prependerState[_type] = prependerState = 
                        new TypePrepender.PrependerState(BuiltinFunction.MakeMethod(_type.Name, _type.GetConstructors(), FunctionType.Function));
                }
            }
            Builder.SetConstructor(new TypePrepender(Builder.UnfinishedType, prependerState));

            Builder.SetDefaultSlotType(delegate(object value) {
                return new PythonTypeUserDescriptorSlot(value);
            });

            ValidateSupportedInheritance();

            IAttributesCollection fastDict = (IAttributesCollection)_vars;

            Builder.AddSlot(Symbols.Name, new PythonTypeValueSlot(_name));
            Builder.AddSlot(Symbols.Module, new PythonTypeValueSlot(fastDict[Symbols.Module]));

            if (fastDict.ContainsKey(Symbols.Slots)) {
                HasSlots = true;
                List<string> slots = NewTypeMaker.SlotsToList(fastDict[Symbols.Slots]);
                if (slots.Contains("__dict__")) HasDictionary = true;
                if (slots.Contains("__weakref__")) HasWeakRef = true;
            } else {
                HasDictionary = true;
                HasWeakRef = true;
            }

            object newInst;
            if (fastDict.TryGetValue(Symbols.NewInst, out newInst) && newInst is PythonFunction) {
                fastDict[Symbols.NewInst] = new staticmethod(newInst);
            }

            PopulateDefaultDictionary(fastDict);

            bool mixedOldNew = InitializeUserType(context, _bases, fastDict);

            PublishDictionary(fastDict);

            Builder.UnfinishedType.OnChange += new EventHandler<PythonTypeChangedEventArgs>(DoOperatorPropagation);
            Builder.IsSystemType = false;

            return (PythonType)Builder.Finish(false);
        }

        private void PublishDictionary(IAttributesCollection dict) {
            foreach (KeyValuePair<SymbolId, object> kvp in dict.SymbolAttributes) {
                PythonTypeSlot dts = kvp.Value as PythonTypeSlot;
                if (dts == null) {
                    dts = CreateValueSlot(kvp.Value);
                }

                Builder.AddSlot(kvp.Key, dts);

                AddLookupOperator(Builder.UnfinishedType, kvp.Key);
            }
        }

        /// <summary>
        /// Adds an operator that does a lookup in the type searching according to normal
        /// lookup rules.
        /// </summary>
        internal static bool AddLookupOperator(PythonType dt, SymbolId id) {
            if (id == Symbols.GetSlice) id = Symbols.GetItem;
            if (id == Symbols.SetSlice) id = Symbols.SetItem;
            if (id == Symbols.DeleteSlice) id = Symbols.DelItem;

            OperatorMapping op;
            if (PythonExtensionTypeAttribute._pythonOperatorTable.TryGetValue(id, out op)) {
                PythonTypeBuilder builder = PythonTypeBuilder.GetBuilder(dt);

                // some operators need specific transformations from the DLR semantics into the 
                // Python semantics - those transformations are done here.
                if (op.Operator == Operators.Call) {
                    builder.AddOperator(Operators.Call, MakeDefaultCall(dt));
                } else if (op.Operator == Operators.GetBoundMember) {
                    builder.AddOperator(op.Operator,
                        delegate(CodeContext context, object self, object other, out object ret) {
                            object value;
                            if (!dt.TryGetBoundMember(context, self, id, out value)) {
                                ret = null;
                                return false;
                            }

                            ret = PythonOps.CallWithContext(context, value, other);
                            return true;
                        }
                    );
                } else if (op.Operator == Operators.SetItem) {
                    AddOperatorSetItem(builder);
                } else if (op.Operator == Operators.GetItem) {
                    AddOperatorGetItem(builder);
                } else if (op.Operator == Operators.DeleteItem) {
                    AddOperatorDeleteItem(builder);
                } else {
                    if (op.IsUnary) {
                        builder.AddOperator(op.Operator,
                            delegate(CodeContext context, object self, out object ret) {
                                object value;
                                if (!dt.TryGetBoundMember(context, self, id, out value)) {
                                    ret = null;
                                    return false;
                                }

                                ret = PythonOps.CallWithContext(context, value);
                                return true;
                            }
                        );
                    }

                    if (op.IsBinary) {
                        builder.AddOperator(op.Operator,
                            delegate(CodeContext context, object self, object other, out object ret) {
                                object value;
                                if (!dt.TryGetBoundMember(context, self, id, out value)) {
                                    ret = null;
                                    return false;
                                }

                                ret = PythonOps.CallWithContext(context, value, other);
                                return true;
                            }
                        );
                    }

                    if (op.IsTernary) {
                        builder.AddOperator(op.Operator,
                            delegate(CodeContext context, object self, object value1, object value2, out object ret) {
                                object value;
                                if (!dt.TryGetBoundMember(context, self, id, out value)) {
                                    ret = null;
                                    return false;
                                }

                                ret = PythonOps.CallWithContext(context,
                                    value,
                                    value1,
                                    value2);
                                return true;
                            }
                        );
                    }
                }
                return true;
            }
            return false;
        }


        internal static void AddOperatorGetItem(PythonTypeBuilder builder) {
            PythonType dt = builder.UnfinishedType;

            builder.AddOperator(Operators.GetItem,
                delegate(CodeContext context, object self, object other, out object ret) {
                    Slice slice = other as Slice;
                    if (slice != null && slice.Step == null) {
                        object getSlice;
                        if (dt.TryGetBoundMember(context, self, Symbols.GetSlice, out getSlice)) {
                            int start, stop;
                            slice.DeprecatedFixed(self, out start, out stop);
                            ret = PythonOps.CallWithContext(context, getSlice, start, stop);
                            return true;
                        }
                    }

                    object value;
                    if (!dt.TryGetBoundMember(context, self, Symbols.GetItem, out value)) {
                        ret = null;
                        return false;
                    }

                    ret = PythonOps.CallWithContext(context,
                        dt.GetBoundMember(context, self, Symbols.GetItem),
                        other);
                    return true;
                }
            );

        }

        internal static void AddOperatorDeleteItem(PythonTypeBuilder builder) {
            PythonType dt = builder.UnfinishedType;

            builder.AddOperator(Operators.DeleteItem,
                delegate(CodeContext context, object self, object other, out object ret) {
                    Slice slice = other as Slice;
                    if (slice != null && slice.Step == null) {
                        object delSlice;
                        if (dt.TryGetBoundMember(context, self, Symbols.DeleteSlice, out delSlice)) {
                            int start, stop;
                            slice.DeprecatedFixed(self, out start, out stop);
                            ret = PythonOps.CallWithContext(context, delSlice, start, stop);
                            return true;
                        }
                    }

                    object value;
                    if (!dt.TryGetBoundMember(context, self, Symbols.DelItem, out value)) {
                        ret = null;
                        return false;
                    }

                    ret = PythonOps.CallWithContext(context,
                        value,
                        other);
                    return true;
                }
            );

        }

        internal static void AddOperatorSetItem(PythonTypeBuilder builder) {
            PythonType dt = builder.UnfinishedType;

            builder.AddOperator(Operators.SetItem,
                delegate(CodeContext context, object self, object value1, object value2, out object ret) {
                    Slice slice = value1 as Slice;
                    if (slice != null && slice.Step == null) {
                        object setSlice;
                        if (dt.TryGetBoundMember(context, self, Symbols.SetSlice, out setSlice)) {
                            int start, stop;
                            slice.DeprecatedFixed(self, out start, out stop);
                            ret = PythonOps.CallWithContext(context, setSlice, start, stop, value2);
                            return true;
                        }
                    }

                    object value;
                    if (!dt.TryGetBoundMember(context, self, Symbols.SetItem, out value)) {
                        ret = null;
                        return false;
                    }

                    ret = PythonOps.CallWithContext(context,
                        value,
                        value1,
                        value2);
                    return true;
                }
            );

        }
        private void DoOperatorPropagation(object sender, PythonTypeChangedEventArgs args) {
            PythonType dt = sender as PythonType;
            Debug.Assert(dt != null);

            if (args.ChangeType == ChangeType.Added) {
                if (args.Symbol == Symbols.GetAttribute) {
                    PythonTypeBuilder dtb = PythonTypeBuilder.GetBuilder(dt);

                    CustomAttributeInfo info = new CustomAttributeInfo(args.NewValue);
                    dtb.SetCustomBoundGetter(info.HookedGetAttribute);
                    dtb.AddSlot(Symbols.GetAttribute, new PythonTypeGetAttributeSlot(dtb.UnfinishedType, info, Symbols.GetAttribute));
                    dtb.SetHasGetAttribute(true);

                    dtb.ReleaseBuilder();
                    return;
                } else if (args.Symbol == Symbols.SetAttr) {
                    PythonTypeBuilder dtb = PythonTypeBuilder.GetBuilder(dt);

                    CustomAttributeInfo info = new CustomAttributeInfo(args.NewValue);
                    dtb.SetCustomSetter(info.HookedSetAttribute);
                    dtb.AddSlot(Symbols.SetAttr, new PythonTypeGetAttributeSlot(dtb.UnfinishedType, info, Symbols.SetAttr));

                    dtb.ReleaseBuilder();
                    return;
                } else if (args.Symbol == Symbols.DelAttr) {
                    PythonTypeBuilder dtb = PythonTypeBuilder.GetBuilder(dt);

                    CustomAttributeInfo info = new CustomAttributeInfo(args.NewValue);
                    dtb.SetCustomDeleter(info.HookedDeleteAttribute);
                    dtb.AddSlot(Symbols.DelAttr, new PythonTypeGetAttributeSlot(dtb.UnfinishedType, info, Symbols.DelAttr));

                    dtb.ReleaseBuilder();
                    return;
                }
            }

            AddOperatorAndPropagate(args.Context, dt, args.Symbol, args.ChangeType, args.PreviousValue);
        }

        protected void AddOperatorAndPropagate(CodeContext context, PythonType dt, SymbolId id, ChangeType type, object previous) {
            if ((type == ChangeType.Added && AddLookupOperator(dt, id)) ||
                (type == ChangeType.Removed && RemoveOperator(dt, id))) {
                IList<WeakReference> subtypes = dt.SubTypes;
                if (subtypes == null) return;

                foreach (WeakReference weaksubtype in subtypes) {
                    if (!weaksubtype.IsAlive) continue;

                    PythonType subtype = (PythonType)weaksubtype.Target;
                    PythonTypeSlot dts;

                    if (subtype.TryLookupSlot(context, id, out dts)) {
                        object oldVal;
                        if (dts.TryGetValue(context, null, subtype, out oldVal) && oldVal == previous) {
                            switch (type) {
                                case ChangeType.Added:
                                    AddLookupOperator(subtype, id);
                                    break;
                                case ChangeType.Removed:
                                    RemoveOperator(subtype, id);
                                    break;
                            }
                        }
                    }
                }
            }
        }

        private static bool RemoveOperator(PythonType dt, SymbolId id) {
            OperatorMapping op;
            if (PythonExtensionTypeAttribute._pythonOperatorTable.TryGetValue(id, out op)) {
                PythonTypeBuilder builder = PythonTypeBuilder.GetBuilder(dt);
                if (op.IsUnary) {
                    builder.AddOperator(op.Operator, (UnaryOperator)null);
                }

                if (op.IsBinary) {
                    builder.AddOperator(op.Operator, (BinaryOperator)null);
                }

                if (op.IsTernary) {
                    builder.AddOperator(op.Operator, (TernaryOperator)null);
                }
                return true;
            }
            return false;
        }

        protected override PythonTypeSlot CreateValueSlot(object value) {
            return new PythonTypeUserDescriptorSlot(value);
        }

        private static object NewDict() {
            return new SymbolDictionary();
        }

        private void ValidateSupportedInheritance() {
            if (_type.GetInterface("ICustomMembers", false) == typeof(ICustomMembers)) {
                // ICustomAttributes is a well-known type. Ops.GetAttr etc first check for it, and dispatch to the
                // ICustomAttributes implementation. At the same time, built-in types like PythonModule, PythonType, 
                // Super, SystemState, etc implement ICustomAttributes. If a user type inherits from these,
                // then Ops.GetAttr still dispatches to the ICustomAttributes implementation of the built-in types
                // instead of checking the user-type.
                if (_vars.ContainsKey(Symbols.GetAttribute))
                    throw new NotImplementedException("Overriding __getattribute__ of built-in types is not implemented");
                if (_vars.ContainsKey(Symbols.SetAttr))
                    throw new NotImplementedException("Overriding __setattr__ of built-in types is not implemented");
                if (_vars.ContainsKey(Symbols.DelAttr))
                    throw new NotImplementedException("Overriding __delattr__ of built-in types is not implemented");
            }

            // we don't support overriding __mro__
            if (_vars.ContainsKey(Symbols.MethodResolutionOrder))
                throw new NotImplementedException("Overriding __mro__ of built-in types is not implemented");

            // cannot override mro when inheriting from type
            if (_vars.ContainsKey(SymbolTable.StringToId("mro"))) {
                foreach (object o in _bases) {
                    PythonType dt = o as PythonType;
                    if (dt != null && dt.IsSubclassOf(TypeCache.PythonType)) {
                        throw new NotImplementedException("Overriding type.mro is not implemented");
                    }
                }
            }
        }

        private void PopulateDefaultDictionary(IAttributesCollection fastDict) {
            if (!fastDict.ContainsKey(Symbols.Doc)) {
                fastDict[Symbols.Doc] = null;
            }

            if (HasWeakRef && !fastDict.ContainsKey(Symbols.WeakRef)) {
                fastDict[Symbols.WeakRef] = new PythonTypeWeakRefSlot(this.Builder.UnfinishedType);
            }

            if (!fastDict.ContainsKey(Symbols.Dict) && HasDictionary) {
                fastDict[Symbols.Dict] = new PythonTypeDictSlot();
            }
        }

        private bool HasWeakRef {
            get {
                return _hasWeakRef;   
            }
            set {
                _hasWeakRef = value;
            }
        }

        private bool HasSlots {
            get {
                return _hasSlots;
            }
            set {
                _hasSlots = value;
            }
        }

        private bool HasDictionary {
            get {
                return _hasDict;
            }
            set {
                _hasDict = value;
            }
        }

        private bool HasFinalizer {
            get {
                return _hasFinalizer;
            }
            set {
                _hasFinalizer = value;
            }
        }

        /// <summary>
        /// Set up the type
        /// </summary>
        /// <param name="context"></param>
        /// <param name="newBases"></param>
        /// <param name="newDict"></param>
        private bool InitializeUserType(CodeContext context, PythonTuple newBases, IAttributesCollection newDict) {
            newBases = EnsureBaseType(newBases);

            for (int i = 0; i < newBases.Count; i++) {
                for (int j = 0; j < newBases.Count; j++) {
                    if (i != j && newBases[i] == newBases[j]) {
                        OldClass oc = newBases[i] as OldClass;
                        if (oc != null) {
                            throw PythonOps.TypeError("duplicate base class {0}", oc.Name);
                        } else {
                            throw PythonOps.TypeError("duplicate base class {0}", ((PythonType)newBases[i]).Name);
                        }
                    }
                }
            }

            List<PythonType> newbs = new List<PythonType>();
            TryGetMemberCustomizer baseCustomizer = null;
            SetMemberCustomizer setCustomizer = null;
            DeleteMemberCustomizer deleteCustomizer = null;
            bool mixedOldNew = false;
            foreach (object typeObj in newBases) {
                PythonType dt = typeObj as PythonType;
                if (dt == null) {
                    dt = ((OldClass)typeObj).TypeObject;
                    mixedOldNew = true;
                }

                newbs.Add(dt);
                baseCustomizer = baseCustomizer ?? dt.CustomBoundGetter;
                setCustomizer = setCustomizer ?? dt.CustomSetter;
                deleteCustomizer = deleteCustomizer ?? dt.CustomDeleter;
            }
            Builder.SetBases(newbs);
            Builder.SetResolutionOrder(Mro.Calculate(Builder.UnfinishedType, newbs));

            InitializeCustomAttributeAccess(newDict, baseCustomizer, setCustomizer, deleteCustomizer);

            if (mixedOldNew) {
                // if we have a mix of old-style & new style classes we need to add
                // every single operator that is available.  This will guarantee we can
                // do the lookup & hit the old-style class if it's there.
                AddAllOperators();
            }

            // if our dict, or any of our children, have a finalizer, then
            // we have a finalizer.
            bool hasFinalizer = newDict.ContainsKey(Symbols.Unassign);

            foreach (PythonType baseTypeObj in Builder.UnfinishedType.BaseTypes) {
                if (baseTypeObj.IsSystemType) continue;

                PythonTypeSlot dts;
                if (baseTypeObj.TryLookupSlot(context, Symbols.Unassign, out dts)) {
                    hasFinalizer = true;
                }
            }

            HasFinalizer = hasFinalizer;

            return mixedOldNew;
        }

        private void InitializeCustomAttributeAccess(IAttributesCollection newDict, TryGetMemberCustomizer baseCustomizer, SetMemberCustomizer setCustomizer, DeleteMemberCustomizer deleteCustomizer) {
            object value;
            if (newDict.TryGetValue(Symbols.GetAttribute, out value)) {
                CustomAttributeInfo info = new CustomAttributeInfo(value);
                Builder.SetCustomBoundGetter(info.HookedGetAttribute);
                newDict[Symbols.GetAttribute] = new PythonTypeGetAttributeSlot(Builder.UnfinishedType, info, Symbols.GetAttribute);
                Builder.SetHasGetAttribute(true);
            } else if (baseCustomizer != null) {
                Builder.SetCustomBoundGetter(baseCustomizer);
            }

            if (newDict.TryGetValue(Symbols.SetAttr, out value)) {
                CustomAttributeInfo info = new CustomAttributeInfo(value);
                Builder.SetCustomSetter(info.HookedSetAttribute);
                newDict[Symbols.SetAttr] = new PythonTypeGetAttributeSlot(Builder.UnfinishedType, info, Symbols.SetAttr);
            } else if (setCustomizer != null) {
                Builder.SetCustomSetter(setCustomizer);
            }

            if (newDict.TryGetValue(Symbols.DelAttr, out value)) {
                CustomAttributeInfo info = new CustomAttributeInfo(value);
                Builder.SetCustomDeleter(info.HookedDeleteAttribute);
                newDict[Symbols.DelAttr] = new PythonTypeGetAttributeSlot(Builder.UnfinishedType, info, Symbols.DelAttr);
            } else if (deleteCustomizer != null) {
                Builder.SetCustomDeleter(deleteCustomizer);
            }
        }

        protected static BinaryOperator MakeDefaultCall(PythonType dt) {
            return delegate(CodeContext context, object self, object other, out object ret) {
                object value;
                if (!dt.TryGetBoundMember(context, self, Symbols.Call, out value)) {
                    ret = null;
                    return false;
                }

                //Console.WriteLine(value);

                if (other.GetType() == typeof(KwCallInfo)) {
                    KwCallInfo kwinfo = (KwCallInfo)other;
                    ret = PythonOps.CallWithKeywordArgs(context,
                        value,
                        kwinfo.Arguments,
                        kwinfo.Names);
                    return true;
                } else {
                    object[] arroth = (object[])other;
                    ret = PythonOps.CallWithContext(context,
                        value,
                        arroth);
                    return true;
                }
            }
            ;
        }

        private void AddAllOperators() {
            Dictionary<SymbolId, OperatorMapping> ops = PythonExtensionTypeAttribute._pythonOperatorTable;

            PythonType dt = Builder.UnfinishedType;
            foreach (KeyValuePair<SymbolId, OperatorMapping> op in ops) {
                AddLookupOperator(Builder.UnfinishedType, op.Key);
            }
        }

        internal class CustomAttributeInfo {
            private object _func;
            private DynamicSite<object, object, string, object> _getAttrSite, _delAttrSite;
            private DynamicSite<object, object, string, object, object> _setAttrSite;

            public CustomAttributeInfo(object value) {
                _func = value;
            }

            public object Function {
                get { return _func; }
                set { _func = value; }
            }

            internal bool HookedGetAttribute(CodeContext context, object instance, SymbolId name, out object value) {
                RuntimeHelpers.CreateSimpleCallSite(ref _getAttrSite);

                try {
                    value = _getAttrSite.Invoke(context, _func, instance, SymbolTable.IdToString(name));
                    return true;
                } catch (MissingMemberException) {
                }
                value = null;
                return false;
            }

            internal void HookedSetAttribute(CodeContext context, object instance, SymbolId name, object value) {
                RuntimeHelpers.CreateSimpleCallSite(ref _setAttrSite);
                _setAttrSite.Invoke(context, _func, instance, SymbolTable.IdToString(name), value);
            }

            internal void HookedDeleteAttribute(CodeContext context, object instance, SymbolId name) {
                RuntimeHelpers.CreateSimpleCallSite(ref _delAttrSite);
                _delAttrSite.Invoke(context, _func, instance, SymbolTable.IdToString(name));
            }
        }

        /// <summary>
        /// If we have only interfaces, we'll need to insert object's base
        /// </summary>
        private static PythonTuple EnsureBaseType(PythonTuple bases) {
            foreach (object baseClass in bases) {
                if (baseClass is OldClass) continue;

                PythonType dt = baseClass as PythonType;

                if (!dt.UnderlyingSystemType.IsInterface)
                    return bases;
            }

            // We found only interfaces. We need do add System.Object to the bases
            return new PythonTuple(bases, TypeCache.Object);
        }

    }
}
