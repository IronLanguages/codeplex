/* ****************************************************************************
 *
 * Copyright (c) Microsoft Corporation. 
 *
 * This source code is subject to terms and conditions of the Microsoft Public License. A 
 * copy of the license can be found in the License.html file at the root of this distribution. If 
 * you cannot locate the  Microsoft Public License, please send an email to 
 * dlr@microsoft.com. By using this source code in any fashion, you are agreeing to be bound 
 * by the terms of the Microsoft Public License.
 *
 * You must not remove this notice, or any other, from this software.
 *
 *
 * ***************************************************************************/
using System; using Microsoft;


using System.Collections.ObjectModel;
using System.Diagnostics;
using Microsoft.Scripting.Utils;
using Microsoft.Linq.Expressions;
using System.Reflection;
using System.Runtime.CompilerServices;
using Microsoft.Runtime.CompilerServices;



namespace Microsoft.Scripting {

    /// <summary>
    /// This holds a set of rules for a particular DynamicSite.  Any given
    /// SmallRuleSet instance is immutable and therefore they may be cached
    /// and shared.  At the moment, the only ones that are shared are
    /// SmallRuleSets with a single rule.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    internal sealed class SmallRuleSet<T> where T : class {
        private T _target;
        private const int MaxRules = 10;
        private readonly CallSiteRule<T>[] _rules;

        // want to start replacing with the last
        private int replaceNext = MaxRules - 1;

        internal SmallRuleSet(CallSiteRule<T>[] rules) {
            _rules = rules;
        }

        internal SmallRuleSet(T target, CallSiteRule<T>[] rules) {
            _rules = rules;
            _target = target;
        }

        internal SmallRuleSet<T> AddRule(CallSiteRule<T> newRule) {
            int count = _rules.Length;

            if (count < MaxRules) {
                count++;
                CallSiteRule<T>[] newSet = new CallSiteRule<T>[count];
                newSet[0] = newRule;

                for (int i = 1; i < count; i++) {
                    newSet[i] = _rules[i - 1];
                }

                return new SmallRuleSet<T>(newSet);
            } else {
                // find replace position using FIFO
                int i = replaceNext;
                replaceNext = (i + 1) % MaxRules;

                _rules[i] = newRule;
                return this;
            }
        }

        internal CallSiteRule<T>[] GetRules() {
            return _rules;
        }

        internal T GetTarget() {
            if (_target == null) {
                _target = MakeTarget();
            }
            return _target;
        }

        private T MakeTarget() {
            Debug.Assert(_rules.Length > 1 || this == _rules[0].RuleSet);

            // We need to forceDynamic because:
            //   * T may not be a visible type
            //   * Rules generated by COM need skipVisibility to access internal
            //     COM objects and methods
            return Stitch().Compile();
        }

        internal Expression<T> Stitch() {
            Type targetType = typeof(T);
            Type siteType = typeof(CallSite<T>);

            int length = _rules.Length;
            Expression[] body = new Expression[length + 1];
            for (int i = 0; i < length; i++) {
                body[i] = _rules[i].Binding;
            }

            var site = Expression.Parameter(typeof(CallSite), "$site");
            var @params = CallSiteRule<T>.Parameters.AddFirst(site);

            Expression Update = Expression.Invoke(
                Expression.Property(
                    Helpers.Convert(site, siteType),
                    typeof(CallSite<T>).GetProperty("Update")
                ),
                new ReadOnlyCollection<Expression>(@params)
            );

            body[_rules.Length] = Expression.Label(
                CallSiteRule<T>.ReturnLabel,
                Expression.Condition(
                    Expression.Call(
                        typeof(CallSiteOps).GetMethod("NeedsUpdate"),
                        @params.First()
                    ),
                    Expression.Default(Update.Type),
                    Update
                )
            );


            return new Expression<T>(
                "_stub_",
                Expression.Block(body),
                new ReadOnlyCollection<ParameterExpression>(@params)
            );
        }
    }
}
