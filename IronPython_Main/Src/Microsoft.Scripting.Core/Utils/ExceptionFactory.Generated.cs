/* ****************************************************************************
 *
 * Copyright (c) Microsoft Corporation. 
 *
 * This source code is subject to terms and conditions of the Microsoft Public License. A 
 * copy of the license can be found in the License.html file at the root of this distribution. If 
 * you cannot locate the  Microsoft Public License, please send an email to 
 * dlr@microsoft.com. By using this source code in any fashion, you are agreeing to be bound 
 * by the terms of the Microsoft Public License.
 *
 * You must not remove this notice, or any other, from this software.
 *
 *
 * ***************************************************************************/

namespace System.Linq.Expressions {

    #region Generated Exception Factory

    // *** BEGIN GENERATED CODE ***
    // generated by function: gen_expr_factory_core from: generate_exception_factory.py

    /// <summary>
    ///    Strongly-typed and parameterized string factory.
    /// </summary>

    internal static partial class Strings {
        /// <summary>
        /// A string like  "DLinq"
        /// </summary>
        internal static string OwningTeam {
            get {
                return "DLinq";
            }
        }

        /// <summary>
        /// A string like  "Method precondition violated"
        /// </summary>
        internal static string MethodPreconditionViolated {
            get {
                return "Method precondition violated";
            }
        }

        /// <summary>
        /// A string like  "Invalid argument value"
        /// </summary>
        internal static string InvalidArgumentValue {
            get {
                return "Invalid argument value";
            }
        }

        /// <summary>
        /// A string like  "Non-empty string required"
        /// </summary>
        internal static string NonEmptyStringRequired {
            get {
                return "Non-empty string required";
            }
        }

        /// <summary>
        /// A string like  "Non-empty collection required"
        /// </summary>
        internal static string NonEmptyCollectionRequired {
            get {
                return "Non-empty collection required";
            }
        }

        /// <summary>
        /// A string like  "must be >= 0"
        /// </summary>
        internal static string MustBePositive {
            get {
                return "must be >= 0";
            }
        }

        /// <summary>
        /// A string like  "Array index must be an int."
        /// </summary>
        internal static string ArrayIndexMustBeInt {
            get {
                return "Array index must be an int.";
            }
        }

        /// <summary>
        /// A string like  "Array argument must be array."
        /// </summary>
        internal static string ArrayArgumentMustBeArray {
            get {
                return "Array argument must be array.";
            }
        }

        /// <summary>
        /// A string like  "Incorrect number of indices."
        /// </summary>
        internal static string IncorrectIndicesCount {
            get {
                return "Incorrect number of indices.";
            }
        }

        /// <summary>
        /// A string like  "Value type must match the array element type."
        /// </summary>
        internal static string ValueTypeMustMatchElementType {
            get {
                return "Value type must match the array element type.";
            }
        }

        /// <summary>
        /// A string like  "right side must be assignable to left side"
        /// </summary>
        internal static string RhsMustBeAssignableToLhs {
            get {
                return "right side must be assignable to left side";
            }
        }

        /// <summary>
        /// A string like  "reducible nodes must override Expression.Reduce()"
        /// </summary>
        internal static string ReducibleMustOverrideReduce {
            get {
                return "reducible nodes must override Expression.Reduce()";
            }
        }

        /// <summary>
        /// A string like  "node cannot reduce to itself or null"
        /// </summary>
        internal static string MustReduceToDifferent {
            get {
                return "node cannot reduce to itself or null";
            }
        }

        /// <summary>
        /// A string like  "cannot assign from the reduced node type to the original node type"
        /// </summary>
        internal static string ReducedNotCompatible {
            get {
                return "cannot assign from the reduced node type to the original node type";
            }
        }

        /// <summary>
        /// A string like  "No getter or setter specified"
        /// </summary>
        internal static string NoGetterSetter {
            get {
                return "No getter or setter specified";
            }
        }

        /// <summary>
        /// A string like  "Setter must have parameters."
        /// </summary>
        internal static string SetterHasNoParams {
            get {
                return "Setter must have parameters.";
            }
        }

        /// <summary>
        /// A string like  "Property cannot have a managed pointer type."
        /// </summary>
        internal static string PropertyCannotHaveRefType {
            get {
                return "Property cannot have a managed pointer type.";
            }
        }

        /// <summary>
        /// A string like  "Indexing parameters of getter and setter must match."
        /// </summary>
        internal static string IndexesOfSetGetMustMatch {
            get {
                return "Indexing parameters of getter and setter must match.";
            }
        }

        /// <summary>
        /// A string like  "Accessor method should not have VarArgs."
        /// </summary>
        internal static string AccessorsCannotHaveVarArgs {
            get {
                return "Accessor method should not have VarArgs.";
            }
        }

        /// <summary>
        /// A string like  "Accessor indexes cannot be passed ByRef."
        /// </summary>
        internal static string AccessorsCannotHaveByRefArgs {
            get {
                return "Accessor indexes cannot be passed ByRef.";
            }
        }

        /// <summary>
        /// A string like  "Incorrect instance type for the field"
        /// </summary>
        internal static string IncorrectInstanceTypeField {
            get {
                return "Incorrect instance type for the field";
            }
        }

        /// <summary>
        /// A string like  "Incorrect value type for the field"
        /// </summary>
        internal static string IncorrectValueTypeField {
            get {
                return "Incorrect value type for the field";
            }
        }

        /// <summary>
        /// A string like  "Incorrect instance type for the property"
        /// </summary>
        internal static string IncorrectinstanceTypeProperty {
            get {
                return "Incorrect instance type for the property";
            }
        }

        /// <summary>
        /// A string like  "set method must have at least one parameter"
        /// </summary>
        internal static string SetMustHaveParams {
            get {
                return "set method must have at least one parameter";
            }
        }

        /// <summary>
        /// A string like  "Incorrect value type for the property"
        /// </summary>
        internal static string IncorrectValueTypeForProperty {
            get {
                return "Incorrect value type for the property";
            }
        }

        /// <summary>
        /// A string like  "Method must be static"
        /// </summary>
        internal static string MustBeStatic {
            get {
                return "Method must be static";
            }
        }

        /// <summary>
        /// A string like  "Incorrect number of arguments"
        /// </summary>
        internal static string IncorrectArgNumber {
            get {
                return "Incorrect number of arguments";
            }
        }

        /// <summary>
        /// A string like  "Argument not provided for a mandatory parameter"
        /// </summary>
        internal static string ArgumentNotProvided {
            get {
                return "Argument not provided for a mandatory parameter";
            }
        }

        /// <summary>
        /// A string like  "Bounds count cannot be less than 1"
        /// </summary>
        internal static string BoundsCannotBeLessThanOne {
            get {
                return "Bounds count cannot be less than 1";
            }
        }

        /// <summary>
        /// A string like  "Value must be int"
        /// </summary>
        internal static string ValueMustBeInt {
            get {
                return "Value must be int";
            }
        }

        /// <summary>
        /// A string like  "Only one default clause allowed"
        /// </summary>
        internal static string OnlyDefaultIsAllowed {
            get {
                return "Only one default clause allowed";
            }
        }

        /// <summary>
        /// A string like  "Case values must be unique"
        /// </summary>
        internal static string CaseValuesMustBeUnique {
            get {
                return "Case values must be unique";
            }
        }

        /// <summary>
        /// A string like  "type must not be ByRef"
        /// </summary>
        internal static string TypeMustNotBeByRef {
            get {
                return "type must not be ByRef";
            }
        }

        /// <summary>
        /// A string like  "operation kind must match node type"
        /// </summary>
        internal static string OperationKindMustMatchNodeType {
            get {
                return "operation kind must match node type";
            }
        }

        /// <summary>
        /// A string like  "Must receive at least one argument, the target to call"
        /// </summary>
        internal static string MustHaveAtLeastTarget {
            get {
                return "Must receive at least one argument, the target to call";
            }
        }

        /// <summary>
        /// A string like  "Property doesn't exist on the provided type"
        /// </summary>
        internal static string PropertyDoesNotExist {
            get {
                return "Property doesn't exist on the provided type";
            }
        }

        /// <summary>
        /// A string like  "Field doesn't exist on provided type"
        /// </summary>
        internal static string FieldDoesNotExist {
            get {
                return "Field doesn't exist on provided type";
            }
        }

        /// <summary>
        /// A string like  "Type doesn't have constructor with a given signature"
        /// </summary>
        internal static string TypeDoesNotHaveConstructorForTheSignature {
            get {
                return "Type doesn't have constructor with a given signature";
            }
        }

        /// <summary>
        /// A string like  "Type doesn't have a method with a given name."
        /// </summary>
        internal static string TypeDoesNotHaveMethodForName {
            get {
                return "Type doesn't have a method with a given name.";
            }
        }

        /// <summary>
        /// A string like  "Type doesn't have a method with a given name and signature."
        /// </summary>
        internal static string TypeDoesNotHaveMethodForNameSignature {
            get {
                return "Type doesn't have a method with a given name and signature.";
            }
        }

        /// <summary>
        /// A string like  "Count must be non-negative."
        /// </summary>
        internal static string CountCannotBeNegative {
            get {
                return "Count must be non-negative.";
            }
        }

        /// <summary>
        /// A string like  "arrayType must be an array type"
        /// </summary>
        internal static string ArrayTypeMustBeArray {
            get {
                return "arrayType must be an array type";
            }
        }

        /// <summary>
        /// A string like  "Setter should have void type."
        /// </summary>
        internal static string SetterMustBeVoid {
            get {
                return "Setter should have void type.";
            }
        }

        /// <summary>
        /// A string like  "Property type must match the value type of setter"
        /// </summary>
        internal static string PropertyTyepMustMatchSetter {
            get {
                return "Property type must match the value type of setter";
            }
        }

        /// <summary>
        /// A string like  "Both accessors must be static."
        /// </summary>
        internal static string BothAccessorsMustBeStatic {
            get {
                return "Both accessors must be static.";
            }
        }

        /// <summary>
        /// A string like  "Static field requires null expression, non-static field requires non-null expression."
        /// </summary>
        internal static string OnlyStaticFieldsHaveNullExpr {
            get {
                return "Static field requires null expression, non-static field requires non-null expression.";
            }
        }

        /// <summary>
        /// A string like  "Static property requires null expression, non-static property requires non-null expression."
        /// </summary>
        internal static string OnlyStaticPropertiesHaveNullExpr {
            get {
                return "Static property requires null expression, non-static property requires non-null expression.";
            }
        }

        /// <summary>
        /// A string like  "Static methods requires null expression, non-static property requires non-null expression."
        /// </summary>
        internal static string OnlyStaticMethodsHaveNullExpr {
            get {
                return "Static methods requires null expression, non-static property requires non-null expression.";
            }
        }

        /// <summary>
        /// A string like  "Property cannot have a void type."
        /// </summary>
        internal static string PropertyTypeCannotBeVoid {
            get {
                return "Property cannot have a void type.";
            }
        }

        /// <summary>
        /// A string like  "Property is not readable"
        /// </summary>
        internal static string PropertyNotReadable {
            get {
                return "Property is not readable";
            }
        }

        /// <summary>
        /// A string like  "Property is not writeable"
        /// </summary>
        internal static string PropertyNotWriteable {
            get {
                return "Property is not writeable";
            }
        }

        /// <summary>
        /// A string like  "Can only unbox from an object or interface type to a value type."
        /// </summary>
        internal static string InvalidUnboxType {
            get {
                return "Can only unbox from an object or interface type to a value type.";
            }
        }

        /// <summary>
        /// A string like  "Expression must be readable"
        /// </summary>
        internal static string ExpressionMustBeReadable {
            get {
                return "Expression must be readable";
            }
        }

        /// <summary>
        /// A string like  "Expression must be writeable"
        /// </summary>
        internal static string ExpressionMustBeWriteable {
            get {
                return "Expression must be writeable";
            }
        }

        /// <summary>
        /// A string like  "Argument must be exception"
        /// </summary>
        internal static string ArgumentMustBeException {
            get {
                return "Argument must be exception";
            }
        }

        /// <summary>
        /// A string like  "subtrees of nodes with non-null type must also have non-null type"
        /// </summary>
        internal static string SubtreesMustBeBound {
            get {
                return "subtrees of nodes with non-null type must also have non-null type";
            }
        }

        /// <summary>
        /// A string like  "readable Expression must reduce to readable Expression"
        /// </summary>
        internal static string MustReduceToReadable {
            get {
                return "readable Expression must reduce to readable Expression";
            }
        }

        /// <summary>
        /// A string like  "writeable Expression must reduce to writeable Expression"
        /// </summary>
        internal static string MustReduceToWriteable {
            get {
                return "writeable Expression must reduce to writeable Expression";
            }
        }

        /// <summary>
        /// A string like  "must be reducible node"
        /// </summary>
        internal static string MustBeReducible {
            get {
                return "must be reducible node";
            }
        }

        /// <summary>
        /// A string like  "must be readable or writeable"
        /// </summary>
        internal static string MustBeReadableOrWriteable {
            get {
                return "must be readable or writeable";
            }
        }

        /// <summary>
        /// A string like  "type or bindingInfo must be non-null"
        /// </summary>
        internal static string TypeOrBindingInfoMustBeNonNull {
            get {
                return "type or bindingInfo must be non-null";
            }
        }

        /// <summary>
        /// A string like  "Start and End must be well ordered"
        /// </summary>
        internal static string StartEndMustBeOrdered {
            get {
                return "Start and End must be well ordered";
            }
        }

        /// <summary>
        /// A string like  "Start and End must both be valid or both invalid"
        /// </summary>
        internal static string StartEndCanOnlyBothBeInvalid {
            get {
                return "Start and End must both be valid or both invalid";
            }
        }

        /// <summary>
        /// A string like  "cannot have finally and fault"
        /// </summary>
        internal static string CannotHaveFinallyAndFault {
            get {
                return "cannot have finally and fault";
            }
        }

        /// <summary>
        /// A string like  "try must have at least one catch, finally, or fault clause"
        /// </summary>
        internal static string TryMustHaveCatchFinallyOrFault {
            get {
                return "try must have at least one catch, finally, or fault clause";
            }
        }

        /// <summary>
        /// A string like  "User-defined operator method '{0}' must be static."
        /// </summary>
        internal static string UserDefinedOperatorMustBeStatic(object p0) {
            return string.Format("User-defined operator method '{0}' must be static.", p0);
        }

        /// <summary>
        /// A string like  "User-defined operator method '{0}' must not be void."
        /// </summary>
        internal static string UserDefinedOperatorMustNotBeVoid(object p0) {
            return string.Format("User-defined operator method '{0}' must not be void.", p0);
        }

        /// <summary>
        /// A string like  "No coercion operator is defined between types '{0}' and '{1}'."
        /// </summary>
        internal static string CoercionOperatorNotDefined(object p0, object p1) {
            return string.Format("No coercion operator is defined between types '{0}' and '{1}'.", p0, p1);
        }

        /// <summary>
        /// A string like  "The unary operator {0} is not defined for the type '{1}'."
        /// </summary>
        internal static string UnaryOperatorNotDefined(object p0, object p1) {
            return string.Format("The unary operator {0} is not defined for the type '{1}'.", p0, p1);
        }

        /// <summary>
        /// A string like  "The binary operator {0} is not defined for the types '{1}' and '{2}'."
        /// </summary>
        internal static string BinaryOperatorNotDefined(object p0, object p1, object p2) {
            return string.Format("The binary operator {0} is not defined for the types '{1}' and '{2}'.", p0, p1, p2);
        }

        /// <summary>
        /// A string like  "The operands for operator '{0}' do not match the parameters of method '{1}'."
        /// </summary>
        internal static string OperandTypesDoNotMatchParameters(object p0, object p1) {
            return string.Format("The operands for operator '{0}' do not match the parameters of method '{1}'.", p0, p1);
        }

        /// <summary>
        /// A string like  "Argument must be array"
        /// </summary>
        internal static string ArgumentMustBeArray {
            get {
                return "Argument must be array";
            }
        }

        /// <summary>
        /// A string like  "Argument must be boolean"
        /// </summary>
        internal static string ArgumentMustBeBoolean {
            get {
                return "Argument must be boolean";
            }
        }

        /// <summary>
        /// A string like  "Argument must be either a FieldInfo or PropertyInfo"
        /// </summary>
        internal static string ArgumentMustBeFieldInfoOrPropertInfo {
            get {
                return "Argument must be either a FieldInfo or PropertyInfo";
            }
        }

        /// <summary>
        /// A string like  "Argument must be either a FieldInfo, PropertyInfo or MethodInfo"
        /// </summary>
        internal static string ArgumentMustBeFieldInfoOrPropertInfoOrMethod {
            get {
                return "Argument must be either a FieldInfo, PropertyInfo or MethodInfo";
            }
        }

        /// <summary>
        /// A string like  "Argument must be an instance member"
        /// </summary>
        internal static string ArgumentMustBeInstanceMember {
            get {
                return "Argument must be an instance member";
            }
        }

        /// <summary>
        /// A string like  "Argument must be of an integer type"
        /// </summary>
        internal static string ArgumentMustBeInteger {
            get {
                return "Argument must be of an integer type";
            }
        }

        /// <summary>
        /// A string like  "Argument for array index must be of type Int32"
        /// </summary>
        internal static string ArgumentMustBeArrayIndexType {
            get {
                return "Argument for array index must be of type Int32";
            }
        }

        /// <summary>
        /// A string like  "Argument must be single dimensional array type"
        /// </summary>
        internal static string ArgumentMustBeSingleDimensionalArrayType {
            get {
                return "Argument must be single dimensional array type";
            }
        }

        /// <summary>
        /// A string like  "Argument types do not match"
        /// </summary>
        internal static string ArgumentTypesMustMatch {
            get {
                return "Argument types do not match";
            }
        }

        /// <summary>
        /// A string like  "Cannot auto initialize elements of value type through property '{0}', use assignment instead"
        /// </summary>
        internal static string CannotAutoInitializeValueTypeElementThroughProperty(object p0) {
            return string.Format("Cannot auto initialize elements of value type through property '{0}', use assignment instead", p0);
        }

        /// <summary>
        /// A string like  "Cannot auto initialize members of value type through property '{0}', use assignment instead"
        /// </summary>
        internal static string CannotAutoInitializeValueTypeMemberThroughProperty(object p0) {
            return string.Format("Cannot auto initialize members of value type through property '{0}', use assignment instead", p0);
        }

        /// <summary>
        /// A string like  "An expression of type '{0}' cannot be cast to type '{1}'"
        /// </summary>
        internal static string CannotCastTypeToType(object p0, object p1) {
            return string.Format("An expression of type '{0}' cannot be cast to type '{1}'", p0, p1);
        }

        /// <summary>
        /// A string like  "The type used in TypeAs Expression must be of reference or nullable type, {0} is neither"
        /// </summary>
        internal static string IncorrectTypeForTypeAs(object p0) {
            return string.Format("The type used in TypeAs Expression must be of reference or nullable type, {0} is neither", p0);
        }

        /// <summary>
        /// A string like  "Coalesce used with type that cannot be null"
        /// </summary>
        internal static string CoalesceUsedOnNonNullType {
            get {
                return "Coalesce used with type that cannot be null";
            }
        }

        /// <summary>
        /// A string like  "An expression of type '{0}' cannot be used to initialize an array of type '{1}'"
        /// </summary>
        internal static string ExpressionTypeCannotInitializeArrayType(object p0, object p1) {
            return string.Format("An expression of type '{0}' cannot be used to initialize an array of type '{1}'", p0, p1);
        }

        /// <summary>
        /// A string like  "Expression of type '{0}' cannot be used for constructor parameter of type '{1}'"
        /// </summary>
        internal static string ExpressionTypeDoesNotMatchConstructorParameter(object p0, object p1) {
            return string.Format("Expression of type '{0}' cannot be used for constructor parameter of type '{1}'", p0, p1);
        }

        /// <summary>
        /// A string like  " Argument type '{0}' does not match the corresponding member type '{1}'"
        /// </summary>
        internal static string ArgumentTypeDoesNotMatchMember(object p0, object p1) {
            return string.Format(" Argument type '{0}' does not match the corresponding member type '{1}'", p0, p1);
        }

        /// <summary>
        /// A string like  " The member '{0}' is not declared on type '{1}' being created"
        /// </summary>
        internal static string ArgumentMemberNotDeclOnType(object p0, object p1) {
            return string.Format(" The member '{0}' is not declared on type '{1}' being created", p0, p1);
        }

        /// <summary>
        /// A string like  "Expression of type '{0}' cannot be used for parameter of type '{1}' of method '{2}'"
        /// </summary>
        internal static string ExpressionTypeDoesNotMatchMethodParameter(object p0, object p1, object p2) {
            return string.Format("Expression of type '{0}' cannot be used for parameter of type '{1}' of method '{2}'", p0, p1, p2);
        }

        /// <summary>
        /// A string like  "Expression of type '{0}' cannot be used for parameter of type '{1}'"
        /// </summary>
        internal static string ExpressionTypeDoesNotMatchParameter(object p0, object p1) {
            return string.Format("Expression of type '{0}' cannot be used for parameter of type '{1}'", p0, p1);
        }

        /// <summary>
        /// A string like  "Expression of type '{0}' cannot be used for return type '{1}'"
        /// </summary>
        internal static string ExpressionTypeDoesNotMatchReturn(object p0, object p1) {
            return string.Format("Expression of type '{0}' cannot be used for return type '{1}'", p0, p1);
        }

        /// <summary>
        /// A string like  "Expression of type '{0}' cannot be used for assignment to type '{1}'"
        /// </summary>
        internal static string ExpressionTypeDoesNotMatchAssignment(object p0, object p1) {
            return string.Format("Expression of type '{0}' cannot be used for assignment to type '{1}'", p0, p1);
        }

        /// <summary>
        /// A string like  "Expression of type '{0}' cannot be invoked"
        /// </summary>
        internal static string ExpressionTypeNotInvocable(object p0) {
            return string.Format("Expression of type '{0}' cannot be invoked", p0);
        }

        /// <summary>
        /// A string like  "Field '{0}' is not defined for type '{1}'"
        /// </summary>
        internal static string FieldNotDefinedForType(object p0, object p1) {
            return string.Format("Field '{0}' is not defined for type '{1}'", p0, p1);
        }

        /// <summary>
        /// A string like  "Incorrect number of indexes"
        /// </summary>
        internal static string IncorrectNumberOfIndexes {
            get {
                return "Incorrect number of indexes";
            }
        }

        /// <summary>
        /// A string like  "Incorrect number of arguments supplied for lambda invocation"
        /// </summary>
        internal static string IncorrectNumberOfLambdaArguments {
            get {
                return "Incorrect number of arguments supplied for lambda invocation";
            }
        }

        /// <summary>
        /// A string like  "Incorrect number of parameters supplied for lambda declaration"
        /// </summary>
        internal static string IncorrectNumberOfLambdaDeclarationParameters {
            get {
                return "Incorrect number of parameters supplied for lambda declaration";
            }
        }

        /// <summary>
        /// A string like  "Incorrect number of arguments supplied for call to method '{0}'"
        /// </summary>
        internal static string IncorrectNumberOfMethodCallArguments(object p0) {
            return string.Format("Incorrect number of arguments supplied for call to method '{0}'", p0);
        }

        /// <summary>
        /// A string like  "Incorrect number of arguments for constructor"
        /// </summary>
        internal static string IncorrectNumberOfConstructorArguments {
            get {
                return "Incorrect number of arguments for constructor";
            }
        }

        /// <summary>
        /// A string like  " Incorrect number of members for constructor"
        /// </summary>
        internal static string IncorrectNumberOfMembersForGivenConstructor {
            get {
                return " Incorrect number of members for constructor";
            }
        }

        /// <summary>
        /// A string like  "Incorrect number of arguments for the given members "
        /// </summary>
        internal static string IncorrectNumberOfArgumentsForMembers {
            get {
                return "Incorrect number of arguments for the given members ";
            }
        }

        /// <summary>
        /// A string like  "Lambda type parameter must be derived from System.Delegate"
        /// </summary>
        internal static string LambdaTypeMustBeDerivedFromSystemDelegate {
            get {
                return "Lambda type parameter must be derived from System.Delegate";
            }
        }

        /// <summary>
        /// A string like  "Member '{0}' not field or property"
        /// </summary>
        internal static string MemberNotFieldOrProperty(object p0) {
            return string.Format("Member '{0}' not field or property", p0);
        }

        /// <summary>
        /// A string like  "Method {0} contains generic parameters"
        /// </summary>
        internal static string MethodContainsGenericParameters(object p0) {
            return string.Format("Method {0} contains generic parameters", p0);
        }

        /// <summary>
        /// A string like  "Method {0} is a generic method definition"
        /// </summary>
        internal static string MethodIsGeneric(object p0) {
            return string.Format("Method {0} is a generic method definition", p0);
        }

        /// <summary>
        /// A string like  "The method '{0}.{1}' is not a property accessor"
        /// </summary>
        internal static string MethodNotPropertyAccessor(object p0, object p1) {
            return string.Format("The method '{0}.{1}' is not a property accessor", p0, p1);
        }

        /// <summary>
        /// A string like  "The property '{0}' has no 'get' accessor"
        /// </summary>
        internal static string PropertyDoesNotHaveGetter(object p0) {
            return string.Format("The property '{0}' has no 'get' accessor", p0);
        }

        /// <summary>
        /// A string like  "The property '{0}' has no 'set' accessor"
        /// </summary>
        internal static string PropertyDoesNotHaveSetter(object p0) {
            return string.Format("The property '{0}' has no 'set' accessor", p0);
        }

        /// <summary>
        /// A string like  "'{0}' is not a member of type '{1}'"
        /// </summary>
        internal static string NotAMemberOfType(object p0, object p1) {
            return string.Format("'{0}' is not a member of type '{1}'", p0, p1);
        }

        /// <summary>
        /// A string like  "The operator '{0}' is not implemented for type '{1}'"
        /// </summary>
        internal static string OperatorNotImplementedForType(object p0, object p1) {
            return string.Format("The operator '{0}' is not implemented for type '{1}'", p0, p1);
        }

        /// <summary>
        /// A string like  "ParameterExpression of type '{0}' cannot be used for delegate parameter of type '{1}'"
        /// </summary>
        internal static string ParameterExpressionNotValidAsDelegate(object p0, object p1) {
            return string.Format("ParameterExpression of type '{0}' cannot be used for delegate parameter of type '{1}'", p0, p1);
        }

        /// <summary>
        /// A string like  "Property '{0}' is not defined for type '{1}'"
        /// </summary>
        internal static string PropertyNotDefinedForType(object p0, object p1) {
            return string.Format("Property '{0}' is not defined for type '{1}'", p0, p1);
        }

        /// <summary>
        /// A string like  "Method '{0}' is not defined for type '{1}'"
        /// </summary>
        internal static string MethodNotDefinedForType(object p0, object p1) {
            return string.Format("Method '{0}' is not defined for type '{1}'", p0, p1);
        }

        /// <summary>
        /// A string like  "Type {0} contains generic parameters"
        /// </summary>
        internal static string TypeContainsGenericParameters(object p0) {
            return string.Format("Type {0} contains generic parameters", p0);
        }

        /// <summary>
        /// A string like  "Type {0} is a generic type definition"
        /// </summary>
        internal static string TypeIsGeneric(object p0) {
            return string.Format("Type {0} is a generic type definition", p0);
        }

        /// <summary>
        /// A string like  "Type '{0}' does not have a default constructor"
        /// </summary>
        internal static string TypeMissingDefaultConstructor(object p0) {
            return string.Format("Type '{0}' does not have a default constructor", p0);
        }

        /// <summary>
        /// A string like  "List initializers must contain at least one initializer"
        /// </summary>
        internal static string ListInitializerWithZeroMembers {
            get {
                return "List initializers must contain at least one initializer";
            }
        }

        /// <summary>
        /// A string like  "Element initializer method must be named 'Add'"
        /// </summary>
        internal static string ElementInitializerMethodNotAdd {
            get {
                return "Element initializer method must be named 'Add'";
            }
        }

        /// <summary>
        /// A string like  "Parameter '{0}' of element initializer method '{1}' must not be a pass by reference parameter"
        /// </summary>
        internal static string ElementInitializerMethodNoRefOutParam(object p0, object p1) {
            return string.Format("Parameter '{0}' of element initializer method '{1}' must not be a pass by reference parameter", p0, p1);
        }

        /// <summary>
        /// A string like  "Element initializer method must have at least 1 parameter"
        /// </summary>
        internal static string ElementInitializerMethodWithZeroArgs {
            get {
                return "Element initializer method must have at least 1 parameter";
            }
        }

        /// <summary>
        /// A string like  "Element initializer method must be an instance method"
        /// </summary>
        internal static string ElementInitializerMethodStatic {
            get {
                return "Element initializer method must be an instance method";
            }
        }

        /// <summary>
        /// A string like  "Type '{0}' is not IEnumerable"
        /// </summary>
        internal static string TypeNotIEnumerable(object p0) {
            return string.Format("Type '{0}' is not IEnumerable", p0);
        }

        /// <summary>
        /// A string like  "Type parameter is {0}. Expected a delegate."
        /// </summary>
        internal static string TypeParameterIsNotDelegate(object p0) {
            return string.Format("Type parameter is {0}. Expected a delegate.", p0);
        }

        /// <summary>
        /// A string like  "Unexpected coalesce operator."
        /// </summary>
        internal static string UnexpectedCoalesceOperator {
            get {
                return "Unexpected coalesce operator.";
            }
        }

        /// <summary>
        /// A string like  "Cannot cast from type '{0}' to type '{1}"
        /// </summary>
        internal static string InvalidCast(object p0, object p1) {
            return string.Format("Cannot cast from type '{0}' to type '{1}", p0, p1);
        }

        /// <summary>
        /// A string like  "Unhandled binary: {0}"
        /// </summary>
        internal static string UnhandledBinary(object p0) {
            return string.Format("Unhandled binary: {0}", p0);
        }

        /// <summary>
        /// A string like  "Unhandled binding "
        /// </summary>
        internal static string UnhandledBinding {
            get {
                return "Unhandled binding ";
            }
        }

        /// <summary>
        /// A string like  "Unhandled Binding Type: {0}"
        /// </summary>
        internal static string UnhandledBindingType(object p0) {
            return string.Format("Unhandled Binding Type: {0}", p0);
        }

        /// <summary>
        /// A string like  "Unhandled convert: {0}"
        /// </summary>
        internal static string UnhandledConvert(object p0) {
            return string.Format("Unhandled convert: {0}", p0);
        }

        /// <summary>
        /// A string like  "Unhandled Expression Type: {0}"
        /// </summary>
        internal static string UnhandledExpressionType(object p0) {
            return string.Format("Unhandled Expression Type: {0}", p0);
        }

        /// <summary>
        /// A string like  "Unhandled unary: {0}"
        /// </summary>
        internal static string UnhandledUnary(object p0) {
            return string.Format("Unhandled unary: {0}", p0);
        }

        /// <summary>
        /// A string like  "Unknown binding type"
        /// </summary>
        internal static string UnknownBindingType {
            get {
                return "Unknown binding type";
            }
        }

        /// <summary>
        /// A string like  "The user-defined operator method '{1}' for operator '{0}' must have identical parameter and return types."
        /// </summary>
        internal static string LogicalOperatorMustHaveConsistentTypes(object p0, object p1) {
            return string.Format("The user-defined operator method '{1}' for operator '{0}' must have identical parameter and return types.", p0, p1);
        }

        /// <summary>
        /// A string like  "The user-defined operator method '{1}' for operator '{0}' must have associated boolean True and False operators."
        /// </summary>
        internal static string LogicalOperatorMustHaveBooleanOperators(object p0, object p1) {
            return string.Format("The user-defined operator method '{1}' for operator '{0}' must have associated boolean True and False operators.", p0, p1);
        }

        /// <summary>
        /// A string like  "No method '{0}' exists on type '{1}'."
        /// </summary>
        internal static string MethodDoesNotExistOnType(object p0, object p1) {
            return string.Format("No method '{0}' exists on type '{1}'.", p0, p1);
        }

        /// <summary>
        /// A string like  "No method '{0}' on type '{1}' is compatible with the supplied arguments."
        /// </summary>
        internal static string MethodWithArgsDoesNotExistOnType(object p0, object p1) {
            return string.Format("No method '{0}' on type '{1}' is compatible with the supplied arguments.", p0, p1);
        }

        /// <summary>
        /// A string like  "More than one method '{0}' on type '{1}' is compatible with the supplied arguments."
        /// </summary>
        internal static string MethodWithMoreThanOneMatch(object p0, object p1) {
            return string.Format("More than one method '{0}' on type '{1}' is compatible with the supplied arguments.", p0, p1);
        }

        /// <summary>
        /// A string like  "An incorrect number of type args were specified for the declaration of a Func type."
        /// </summary>
        internal static string IncorrectNumberOfTypeArgsForFunc {
            get {
                return "An incorrect number of type args were specified for the declaration of a Func type.";
            }
        }

        /// <summary>
        /// A string like  "An incorrect number of type args were specified for the declaration of an Action type."
        /// </summary>
        internal static string IncorrectNumberOfTypeArgsForAction {
            get {
                return "An incorrect number of type args were specified for the declaration of an Action type.";
            }
        }

        /// <summary>
        /// A string like  "A lambda expression cannot contain pass by reference parameters."
        /// </summary>
        internal static string ExpressionMayNotContainByrefParameters {
            get {
                return "A lambda expression cannot contain pass by reference parameters.";
            }
        }

        /// <summary>
        /// A string like  "Argument type cannot be System.Void."
        /// </summary>
        internal static string ArgumentCannotBeOfTypeVoid {
            get {
                return "Argument type cannot be System.Void.";
            }
        }

        /// <summary>
        /// A string like  "No or Invalid rule produced"
        /// </summary>
        internal static string NoOrInvalidRuleProduced {
            get {
                return "No or Invalid rule produced";
            }
        }

        /// <summary>
        /// A string like  "RuleBuilder can only be used with delegates whose first argument is CallSite."
        /// </summary>
        internal static string FirstArgumentMustBeCallSite {
            get {
                return "RuleBuilder can only be used with delegates whose first argument is CallSite.";
            }
        }

        /// <summary>
        /// A string like  "Bind cannot return null."
        /// </summary>
        internal static string BindingCannotBeNull {
            get {
                return "Bind cannot return null.";
            }
        }

        /// <summary>
        /// A string like  "Empty rule set does not have target."
        /// </summary>
        internal static string EmptyRuleSetTarget {
            get {
                return "Empty rule set does not have target.";
            }
        }

        /// <summary>
        /// A string like  "Left side of assignment is not an assignable node type."
        /// </summary>
        internal static string LhsUnassignable {
            get {
                return "Left side of assignment is not an assignable node type.";
            }
        }

        /// <summary>
        /// A string like  "Bad data bound to delegate."
        /// </summary>
        internal static string BadDelegateData {
            get {
                return "Bad data bound to delegate.";
            }
        }

        /// <summary>
        /// A string like  "Elements must be variables or parameters: {0}"
        /// </summary>
        internal static string MustBeVariableOrParameter(object p0) {
            return string.Format("Elements must be variables or parameters: {0}", p0);
        }

        /// <summary>
        /// A string like  "Argument count (including instance) '{0}' must match arguments in the binding information '{1}'"
        /// </summary>
        internal static string ArgumentCountMustMatchBinding(object p0, object p1) {
            return string.Format("Argument count (including instance) '{0}' must match arguments in the binding information '{1}'", p0, p1);
        }

        /// <summary>
        /// A string like  "Invalid operation: '{0}'"
        /// </summary>
        internal static string InvalidOperation(object p0) {
            return string.Format("Invalid operation: '{0}'", p0);
        }

        /// <summary>
        /// A string like  "{0} must be greater than or equal to {1}"
        /// </summary>
        internal static string OutOfRange(object p0, object p1) {
            return string.Format("{0} must be greater than or equal to {1}", p0, p1);
        }

        /// <summary>
        /// A string like  "Removing an event handler that is not registered."
        /// </summary>
        internal static string RemovingUnregisteredEvent {
            get {
                return "Removing an event handler that is not registered.";
            }
        }

        /// <summary>
        /// A string like  "COM object does not support events."
        /// </summary>
        internal static string COMObjectDoesNotSupportEvents {
            get {
                return "COM object does not support events.";
            }
        }

        /// <summary>
        /// A string like  "COM object does not support specified source interface."
        /// </summary>
        internal static string COMObjectDoesNotSupportSourceInterface {
            get {
                return "COM object does not support specified source interface.";
            }
        }

        /// <summary>
        /// A string like  "Removing not registered handler."
        /// </summary>
        internal static string RemovingUnregisteredHandler {
            get {
                return "Removing not registered handler.";
            }
        }

        /// <summary>
        /// A string like  "Marshal.SetComObjectData failed."
        /// </summary>
        internal static string SetComObjectDataFailed {
            get {
                return "Marshal.SetComObjectData failed.";
            }
        }

        /// <summary>
        /// A string like  "TypeLib '{0}' does not contain COM interface '{1}'."
        /// </summary>
        internal static string TypeLibDoesNotContainInterface(object p0, object p1) {
            return string.Format("TypeLib '{0}' does not contain COM interface '{1}'.", p0, p1);
        }

        /// <summary>
        /// A string like  "This method exists only to keep the compiler happy."
        /// </summary>
        internal static string MethodShouldNotBeCalled {
            get {
                return "This method exists only to keep the compiler happy.";
            }
        }

        /// <summary>
        /// A string like  "Default value of COM parameter cannot be read properly."
        /// </summary>
        internal static string DefaultValueCannotBeRead {
            get {
                return "Default value of COM parameter cannot be read properly.";
            }
        }

        /// <summary>
        /// A string like  "Unexpected VarEnum {0}."
        /// </summary>
        internal static string UnexpectedVarEnum(object p0) {
            return string.Format("Unexpected VarEnum {0}.", p0);
        }

        /// <summary>
        /// A string like  "Error while invoking {0}."
        /// </summary>
        internal static string DispBadParamCount(object p0) {
            return string.Format("Error while invoking {0}.", p0);
        }

        /// <summary>
        /// A string like  "Error while invoking {0}."
        /// </summary>
        internal static string DispMemberNotFound(object p0) {
            return string.Format("Error while invoking {0}.", p0);
        }

        /// <summary>
        /// A string like  "Error while invoking {0}. Named arguments are not supported."
        /// </summary>
        internal static string DispNoNamedArgs(object p0) {
            return string.Format("Error while invoking {0}. Named arguments are not supported.", p0);
        }

        /// <summary>
        /// A string like  "Error while invoking {0}."
        /// </summary>
        internal static string DispOverflow(object p0) {
            return string.Format("Error while invoking {0}.", p0);
        }

        /// <summary>
        /// A string like  "Could not convert argument {0} for call to {1}."
        /// </summary>
        internal static string DispTypeMismatch(object p0, object p1) {
            return string.Format("Could not convert argument {0} for call to {1}.", p0, p1);
        }

        /// <summary>
        /// A string like  "Error while invoking {0}. A required parameter was omitted."
        /// </summary>
        internal static string DispParamNotOptional(object p0) {
            return string.Format("Error while invoking {0}. A required parameter was omitted.", p0);
        }

        /// <summary>
        /// A string like  "ResolveComReference.CannotRetrieveTypeInformation."
        /// </summary>
        internal static string CannotRetrieveTypeInformation {
            get {
                return "ResolveComReference.CannotRetrieveTypeInformation.";
            }
        }

        /// <summary>
        /// A string like  "IDispatch::GetIDsOfNames behaved unexpectedly for {0}."
        /// </summary>
        internal static string GetIDsOfNamesInvalid(object p0) {
            return string.Format("IDispatch::GetIDsOfNames behaved unexpectedly for {0}.", p0);
        }

        /// <summary>
        /// A string like  "Attempting to wrap an unsupported enum type."
        /// </summary>
        internal static string UnsupportedEnumType {
            get {
                return "Attempting to wrap an unsupported enum type.";
            }
        }

        /// <summary>
        /// A string like  "COM object is expected."
        /// </summary>
        internal static string ComObjectExpected {
            get {
                return "COM object is expected.";
            }
        }

        /// <summary>
        /// A string like  "Could not get DispId for {0} (error:{1})."
        /// </summary>
        internal static string CouldNotGetDispId(object p0, object p1) {
            return string.Format("Could not get DispId for {0} (error:{1}).", p0, p1);
        }

        /// <summary>
        /// A string like  "There are valid conversions from {0} to {1}."
        /// </summary>
        internal static string AmbiguousConversion(object p0, object p1) {
            return string.Format("There are valid conversions from {0} to {1}.", p0, p1);
        }

        /// <summary>
        /// A string like  "Variant.ToObject cannot handle {0}."
        /// </summary>
        internal static string VariantToObjectNYI(object p0) {
            return string.Format("Variant.ToObject cannot handle {0}.", p0);
        }

        /// <summary>
        /// A string like  "Variant.GetAccessor cannot handle {0}."
        /// </summary>
        internal static string VariantGetAccessorNYI(object p0) {
            return string.Format("Variant.GetAccessor cannot handle {0}.", p0);
        }

        /// <summary>
        /// A string like  "Queue empty."
        /// </summary>
        internal static string QueueEmpty {
            get {
                return "Queue empty.";
            }
        }

        /// <summary>
        /// A string like  "Cannot emit address of void-typed block."
        /// </summary>
        internal static string AddressOfVoidBlock {
            get {
                return "Cannot emit address of void-typed block.";
            }
        }

        /// <summary>
        /// A string like  "Statement not on the stack."
        /// </summary>
        internal static string StatementNotOnStack {
            get {
                return "Statement not on the stack.";
            }
        }

        /// <summary>
        /// A string like  "Dynamic expression not reduced."
        /// </summary>
        internal static string DynamicNotReduced {
            get {
                return "Dynamic expression not reduced.";
            }
        }

        /// <summary>
        /// A string like  "Action should have been reduced."
        /// </summary>
        internal static string ActionNotReduced {
            get {
                return "Action should have been reduced.";
            }
        }

        /// <summary>
        /// A string like  "Delete should have been reduced."
        /// </summary>
        internal static string DeleteNotReduced {
            get {
                return "Delete should have been reduced.";
            }
        }

        /// <summary>
        /// A string like  "Extension should have been reduced."
        /// </summary>
        internal static string ExtensionNotReduced {
            get {
                return "Extension should have been reduced.";
            }
        }

        /// <summary>
        /// A string like  "Runtime constants require a bound delegate."
        /// </summary>
        internal static string RtConstRequiresBundDelegate {
            get {
                return "Runtime constants require a bound delegate.";
            }
        }

        /// <summary>
        /// A string like  "Invalid lvalue for assignment: {0}."
        /// </summary>
        internal static string InvalidLvalue(object p0) {
            return string.Format("Invalid lvalue for assignment: {0}.", p0);
        }

        /// <summary>
        /// A string like  "Invalid member type: {0}."
        /// </summary>
        internal static string InvalidMemberType(object p0) {
            return string.Format("Invalid member type: {0}.", p0);
        }

        /// <summary>
        /// A string like  "unknown lift type: '{0}'."
        /// </summary>
        internal static string UnknownLiftType(object p0) {
            return string.Format("unknown lift type: '{0}'.", p0);
        }

        /// <summary>
        /// A string like  "Invalid output directory."
        /// </summary>
        internal static string InvalidOutputDir {
            get {
                return "Invalid output directory.";
            }
        }

        /// <summary>
        /// A string like  "Invalid assembly name or file extension."
        /// </summary>
        internal static string InvalidAsmNameOrExtension {
            get {
                return "Invalid assembly name or file extension.";
            }
        }

        /// <summary>
        /// A string like  "Cannot emit constant {0} ({1})"
        /// </summary>
        internal static string CanotEmitConstant(object p0, object p1) {
            return string.Format("Cannot emit constant {0} ({1})", p0, p1);
        }

        /// <summary>
        /// A string like  "No implicit cast from {0} to {1}"
        /// </summary>
        internal static string NoImplicitCast(object p0, object p1) {
            return string.Format("No implicit cast from {0} to {1}", p0, p1);
        }

        /// <summary>
        /// A string like  "No explicit cast from {0} to {1}"
        /// </summary>
        internal static string NoExplicitCast(object p0, object p1) {
            return string.Format("No explicit cast from {0} to {1}", p0, p1);
        }

        /// <summary>
        /// A string like  "No default value for a given type."
        /// </summary>
        internal static string NoDefaultValue {
            get {
                return "No default value for a given type.";
            }
        }

        /// <summary>
        /// A string like  "Stack changed while enumerating."
        /// </summary>
        internal static string StackChangedWhileEnumerationg {
            get {
                return "Stack changed while enumerating.";
            }
        }

        /// <summary>
        /// A string like  "Collection is read-only."
        /// </summary>
        internal static string CollectionReadOnly {
            get {
                return "Collection is read-only.";
            }
        }

        /// <summary>
        /// A string like  "can't read from property"
        /// </summary>
        internal static string CantReadProperty {
            get {
                return "can't read from property";
            }
        }

        /// <summary>
        /// A string like  "can't write to property"
        /// </summary>
        internal static string CantWriteProperty {
            get {
                return "can't write to property";
            }
        }

        /// <summary>
        /// A string like  "Cannot create instance of {0} because it contains generic parameters"
        /// </summary>
        internal static string IllegalNew_GenericParams(object p0) {
            return string.Format("Cannot create instance of {0} because it contains generic parameters", p0);
        }

        /// <summary>
        /// A string like  "Non-verifiable assembly generated: {0}:\nAssembly preserved as {1}\nError text:\n{2}\n"
        /// </summary>
        internal static string VerificationException(object p0, object p1, object p2) {
            return string.Format("Non-verifiable assembly generated: {0}:\nAssembly preserved as {1}\nError text:\n{2}\n", p0, p1, p2);
        }

        /// <summary>
        /// A string like  "Variable '{0}' referenced from lambda '{1}', but it is not defined in an outer scope"
        /// </summary>
        internal static string UnboundVariable(object p0, object p1) {
            return string.Format("Variable '{0}' referenced from lambda '{1}', but it is not defined in an outer scope", p0, p1);
        }

        /// <summary>
        /// A string like  "yield outside of generator in lambda '{0}'"
        /// </summary>
        internal static string YieldOutsideOfGenerator(object p0) {
            return string.Format("yield outside of generator in lambda '{0}'", p0);
        }

        /// <summary>
        /// A string like  "Expression of type '{0}' cannot be used for return type '{1}' of lambda '{2}'"
        /// </summary>
        internal static string InvalidReturnTypeOfLambda(object p0, object p1, object p2) {
            return string.Format("Expression of type '{0}' cannot be used for return type '{1}' of lambda '{2}'", p0, p1, p2);
        }

        /// <summary>
        /// A string like  "Expression missing for return in lambda '{0}', must have return type '{1}'"
        /// </summary>
        internal static string MissingReturnForLambda(object p0, object p1) {
            return string.Format("Expression missing for return in lambda '{0}', must have return type '{1}'", p0, p1);
        }

        /// <summary>
        /// A string like  "Cannot close over byref parameter '{0}' referenced in lambda '{1}'"
        /// </summary>
        internal static string CannotCloseOverByRef(object p0, object p1) {
            return string.Format("Cannot close over byref parameter '{0}' referenced in lambda '{1}'", p0, p1);
        }

        /// <summary>
        /// A string like  "Expected type {0}, got {1}."
        /// </summary>
        internal static string UnexpectedType(object p0, object p1) {
            return string.Format("Expected type {0}, got {1}.", p0, p1);
        }

    }
    /// <summary>
    ///    Strongly-typed and parameterized exception factory.
    /// </summary>

    internal static partial class Error {
        /// <summary>
        /// ArgumentException with message like "type or bindingInfo must be non-null"
        /// </summary>
        internal static Exception TypeOrBindingInfoMustBeNonNull() {
            return new ArgumentException(Strings.TypeOrBindingInfoMustBeNonNull);
        }

        /// <summary>
        /// ArgumentException with message like "Start and End must be well ordered"
        /// </summary>
        internal static Exception StartEndMustBeOrdered() {
            return new ArgumentException(Strings.StartEndMustBeOrdered);
        }

        /// <summary>
        /// ArgumentException with message like "Start and End must both be valid or both invalid"
        /// </summary>
        internal static Exception StartEndCanOnlyBothBeInvalid() {
            return new ArgumentException(Strings.StartEndCanOnlyBothBeInvalid);
        }

        /// <summary>
        /// ArgumentException with message like "cannot have finally and fault"
        /// </summary>
        internal static Exception CannotHaveFinallyAndFault() {
            return new ArgumentException(Strings.CannotHaveFinallyAndFault);
        }

        /// <summary>
        /// ArgumentException with message like "try must have at least one catch, finally, or fault clause"
        /// </summary>
        internal static Exception TryMustHaveCatchFinallyOrFault() {
            return new ArgumentException(Strings.TryMustHaveCatchFinallyOrFault);
        }

        /// <summary>
        /// ArgumentException with message like "User-defined operator method '{0}' must be static."
        /// </summary>
        internal static Exception UserDefinedOperatorMustBeStatic(object p0) {
            return new ArgumentException(Strings.UserDefinedOperatorMustBeStatic(p0));
        }

        /// <summary>
        /// ArgumentException with message like "User-defined operator method '{0}' must not be void."
        /// </summary>
        internal static Exception UserDefinedOperatorMustNotBeVoid(object p0) {
            return new ArgumentException(Strings.UserDefinedOperatorMustNotBeVoid(p0));
        }

        /// <summary>
        /// InvalidOperationException with message like "No coercion operator is defined between types '{0}' and '{1}'."
        /// </summary>
        internal static Exception CoercionOperatorNotDefined(object p0, object p1) {
            return new InvalidOperationException(Strings.CoercionOperatorNotDefined(p0, p1));
        }

        /// <summary>
        /// InvalidOperationException with message like "The unary operator {0} is not defined for the type '{1}'."
        /// </summary>
        internal static Exception UnaryOperatorNotDefined(object p0, object p1) {
            return new InvalidOperationException(Strings.UnaryOperatorNotDefined(p0, p1));
        }

        /// <summary>
        /// InvalidOperationException with message like "The binary operator {0} is not defined for the types '{1}' and '{2}'."
        /// </summary>
        internal static Exception BinaryOperatorNotDefined(object p0, object p1, object p2) {
            return new InvalidOperationException(Strings.BinaryOperatorNotDefined(p0, p1, p2));
        }

        /// <summary>
        /// InvalidOperationException with message like "The operands for operator '{0}' do not match the parameters of method '{1}'."
        /// </summary>
        internal static Exception OperandTypesDoNotMatchParameters(object p0, object p1) {
            return new InvalidOperationException(Strings.OperandTypesDoNotMatchParameters(p0, p1));
        }

        /// <summary>
        /// ArgumentException with message like "Argument must be array"
        /// </summary>
        internal static Exception ArgumentMustBeArray() {
            return new ArgumentException(Strings.ArgumentMustBeArray);
        }

        /// <summary>
        /// ArgumentException with message like "Argument must be boolean"
        /// </summary>
        internal static Exception ArgumentMustBeBoolean() {
            return new ArgumentException(Strings.ArgumentMustBeBoolean);
        }

        /// <summary>
        /// ArgumentException with message like "Argument must be either a FieldInfo or PropertyInfo"
        /// </summary>
        internal static Exception ArgumentMustBeFieldInfoOrPropertInfo() {
            return new ArgumentException(Strings.ArgumentMustBeFieldInfoOrPropertInfo);
        }

        /// <summary>
        /// ArgumentException with message like "Argument must be either a FieldInfo, PropertyInfo or MethodInfo"
        /// </summary>
        internal static Exception ArgumentMustBeFieldInfoOrPropertInfoOrMethod() {
            return new ArgumentException(Strings.ArgumentMustBeFieldInfoOrPropertInfoOrMethod);
        }

        /// <summary>
        /// ArgumentException with message like "Argument must be an instance member"
        /// </summary>
        internal static Exception ArgumentMustBeInstanceMember() {
            return new ArgumentException(Strings.ArgumentMustBeInstanceMember);
        }

        /// <summary>
        /// ArgumentException with message like "Argument must be of an integer type"
        /// </summary>
        internal static Exception ArgumentMustBeInteger() {
            return new ArgumentException(Strings.ArgumentMustBeInteger);
        }

        /// <summary>
        /// ArgumentException with message like "Argument for array index must be of type Int32"
        /// </summary>
        internal static Exception ArgumentMustBeArrayIndexType() {
            return new ArgumentException(Strings.ArgumentMustBeArrayIndexType);
        }

        /// <summary>
        /// ArgumentException with message like "Argument must be single dimensional array type"
        /// </summary>
        internal static Exception ArgumentMustBeSingleDimensionalArrayType() {
            return new ArgumentException(Strings.ArgumentMustBeSingleDimensionalArrayType);
        }

        /// <summary>
        /// ArgumentException with message like "Argument types do not match"
        /// </summary>
        internal static Exception ArgumentTypesMustMatch() {
            return new ArgumentException(Strings.ArgumentTypesMustMatch);
        }

        /// <summary>
        /// InvalidOperationException with message like "Cannot auto initialize elements of value type through property '{0}', use assignment instead"
        /// </summary>
        internal static Exception CannotAutoInitializeValueTypeElementThroughProperty(object p0) {
            return new InvalidOperationException(Strings.CannotAutoInitializeValueTypeElementThroughProperty(p0));
        }

        /// <summary>
        /// InvalidOperationException with message like "Cannot auto initialize members of value type through property '{0}', use assignment instead"
        /// </summary>
        internal static Exception CannotAutoInitializeValueTypeMemberThroughProperty(object p0) {
            return new InvalidOperationException(Strings.CannotAutoInitializeValueTypeMemberThroughProperty(p0));
        }

        /// <summary>
        /// ArgumentException with message like "An expression of type '{0}' cannot be cast to type '{1}'"
        /// </summary>
        internal static Exception CannotCastTypeToType(object p0, object p1) {
            return new ArgumentException(Strings.CannotCastTypeToType(p0, p1));
        }

        /// <summary>
        /// ArgumentException with message like "The type used in TypeAs Expression must be of reference or nullable type, {0} is neither"
        /// </summary>
        internal static Exception IncorrectTypeForTypeAs(object p0) {
            return new ArgumentException(Strings.IncorrectTypeForTypeAs(p0));
        }

        /// <summary>
        /// InvalidOperationException with message like "Coalesce used with type that cannot be null"
        /// </summary>
        internal static Exception CoalesceUsedOnNonNullType() {
            return new InvalidOperationException(Strings.CoalesceUsedOnNonNullType);
        }

        /// <summary>
        /// InvalidOperationException with message like "An expression of type '{0}' cannot be used to initialize an array of type '{1}'"
        /// </summary>
        internal static Exception ExpressionTypeCannotInitializeArrayType(object p0, object p1) {
            return new InvalidOperationException(Strings.ExpressionTypeCannotInitializeArrayType(p0, p1));
        }

        /// <summary>
        /// ArgumentException with message like "Expression of type '{0}' cannot be used for constructor parameter of type '{1}'"
        /// </summary>
        internal static Exception ExpressionTypeDoesNotMatchConstructorParameter(object p0, object p1) {
            return new ArgumentException(Strings.ExpressionTypeDoesNotMatchConstructorParameter(p0, p1));
        }

        /// <summary>
        /// ArgumentException with message like " Argument type '{0}' does not match the corresponding member type '{1}'"
        /// </summary>
        internal static Exception ArgumentTypeDoesNotMatchMember(object p0, object p1) {
            return new ArgumentException(Strings.ArgumentTypeDoesNotMatchMember(p0, p1));
        }

        /// <summary>
        /// ArgumentException with message like " The member '{0}' is not declared on type '{1}' being created"
        /// </summary>
        internal static Exception ArgumentMemberNotDeclOnType(object p0, object p1) {
            return new ArgumentException(Strings.ArgumentMemberNotDeclOnType(p0, p1));
        }

        /// <summary>
        /// ArgumentException with message like "Expression of type '{0}' cannot be used for parameter of type '{1}' of method '{2}'"
        /// </summary>
        internal static Exception ExpressionTypeDoesNotMatchMethodParameter(object p0, object p1, object p2) {
            return new ArgumentException(Strings.ExpressionTypeDoesNotMatchMethodParameter(p0, p1, p2));
        }

        /// <summary>
        /// ArgumentException with message like "Expression of type '{0}' cannot be used for parameter of type '{1}'"
        /// </summary>
        internal static Exception ExpressionTypeDoesNotMatchParameter(object p0, object p1) {
            return new ArgumentException(Strings.ExpressionTypeDoesNotMatchParameter(p0, p1));
        }

        /// <summary>
        /// ArgumentException with message like "Expression of type '{0}' cannot be used for return type '{1}'"
        /// </summary>
        internal static Exception ExpressionTypeDoesNotMatchReturn(object p0, object p1) {
            return new ArgumentException(Strings.ExpressionTypeDoesNotMatchReturn(p0, p1));
        }

        /// <summary>
        /// ArgumentException with message like "Expression of type '{0}' cannot be used for assignment to type '{1}'"
        /// </summary>
        internal static Exception ExpressionTypeDoesNotMatchAssignment(object p0, object p1) {
            return new ArgumentException(Strings.ExpressionTypeDoesNotMatchAssignment(p0, p1));
        }

        /// <summary>
        /// ArgumentException with message like "Expression of type '{0}' cannot be invoked"
        /// </summary>
        internal static Exception ExpressionTypeNotInvocable(object p0) {
            return new ArgumentException(Strings.ExpressionTypeNotInvocable(p0));
        }

        /// <summary>
        /// ArgumentException with message like "Field '{0}' is not defined for type '{1}'"
        /// </summary>
        internal static Exception FieldNotDefinedForType(object p0, object p1) {
            return new ArgumentException(Strings.FieldNotDefinedForType(p0, p1));
        }

        /// <summary>
        /// ArgumentException with message like "Incorrect number of indexes"
        /// </summary>
        internal static Exception IncorrectNumberOfIndexes() {
            return new ArgumentException(Strings.IncorrectNumberOfIndexes);
        }

        /// <summary>
        /// InvalidOperationException with message like "Incorrect number of arguments supplied for lambda invocation"
        /// </summary>
        internal static Exception IncorrectNumberOfLambdaArguments() {
            return new InvalidOperationException(Strings.IncorrectNumberOfLambdaArguments);
        }

        /// <summary>
        /// ArgumentException with message like "Incorrect number of parameters supplied for lambda declaration"
        /// </summary>
        internal static Exception IncorrectNumberOfLambdaDeclarationParameters() {
            return new ArgumentException(Strings.IncorrectNumberOfLambdaDeclarationParameters);
        }

        /// <summary>
        /// ArgumentException with message like "Incorrect number of arguments supplied for call to method '{0}'"
        /// </summary>
        internal static Exception IncorrectNumberOfMethodCallArguments(object p0) {
            return new ArgumentException(Strings.IncorrectNumberOfMethodCallArguments(p0));
        }

        /// <summary>
        /// ArgumentException with message like "Incorrect number of arguments for constructor"
        /// </summary>
        internal static Exception IncorrectNumberOfConstructorArguments() {
            return new ArgumentException(Strings.IncorrectNumberOfConstructorArguments);
        }

        /// <summary>
        /// ArgumentException with message like " Incorrect number of members for constructor"
        /// </summary>
        internal static Exception IncorrectNumberOfMembersForGivenConstructor() {
            return new ArgumentException(Strings.IncorrectNumberOfMembersForGivenConstructor);
        }

        /// <summary>
        /// ArgumentException with message like "Incorrect number of arguments for the given members "
        /// </summary>
        internal static Exception IncorrectNumberOfArgumentsForMembers() {
            return new ArgumentException(Strings.IncorrectNumberOfArgumentsForMembers);
        }

        /// <summary>
        /// ArgumentException with message like "Lambda type parameter must be derived from System.Delegate"
        /// </summary>
        internal static Exception LambdaTypeMustBeDerivedFromSystemDelegate() {
            return new ArgumentException(Strings.LambdaTypeMustBeDerivedFromSystemDelegate);
        }

        /// <summary>
        /// ArgumentException with message like "Member '{0}' not field or property"
        /// </summary>
        internal static Exception MemberNotFieldOrProperty(object p0) {
            return new ArgumentException(Strings.MemberNotFieldOrProperty(p0));
        }

        /// <summary>
        /// ArgumentException with message like "Method {0} contains generic parameters"
        /// </summary>
        internal static Exception MethodContainsGenericParameters(object p0) {
            return new ArgumentException(Strings.MethodContainsGenericParameters(p0));
        }

        /// <summary>
        /// ArgumentException with message like "Method {0} is a generic method definition"
        /// </summary>
        internal static Exception MethodIsGeneric(object p0) {
            return new ArgumentException(Strings.MethodIsGeneric(p0));
        }

        /// <summary>
        /// ArgumentException with message like "The method '{0}.{1}' is not a property accessor"
        /// </summary>
        internal static Exception MethodNotPropertyAccessor(object p0, object p1) {
            return new ArgumentException(Strings.MethodNotPropertyAccessor(p0, p1));
        }

        /// <summary>
        /// ArgumentException with message like "The property '{0}' has no 'get' accessor"
        /// </summary>
        internal static Exception PropertyDoesNotHaveGetter(object p0) {
            return new ArgumentException(Strings.PropertyDoesNotHaveGetter(p0));
        }

        /// <summary>
        /// ArgumentException with message like "The property '{0}' has no 'set' accessor"
        /// </summary>
        internal static Exception PropertyDoesNotHaveSetter(object p0) {
            return new ArgumentException(Strings.PropertyDoesNotHaveSetter(p0));
        }

        /// <summary>
        /// ArgumentException with message like "'{0}' is not a member of type '{1}'"
        /// </summary>
        internal static Exception NotAMemberOfType(object p0, object p1) {
            return new ArgumentException(Strings.NotAMemberOfType(p0, p1));
        }

        /// <summary>
        /// NotImplementedException with message like "The operator '{0}' is not implemented for type '{1}'"
        /// </summary>
        internal static Exception OperatorNotImplementedForType(object p0, object p1) {
            return new NotImplementedException(Strings.OperatorNotImplementedForType(p0, p1));
        }

        /// <summary>
        /// ArgumentException with message like "ParameterExpression of type '{0}' cannot be used for delegate parameter of type '{1}'"
        /// </summary>
        internal static Exception ParameterExpressionNotValidAsDelegate(object p0, object p1) {
            return new ArgumentException(Strings.ParameterExpressionNotValidAsDelegate(p0, p1));
        }

        /// <summary>
        /// ArgumentException with message like "Property '{0}' is not defined for type '{1}'"
        /// </summary>
        internal static Exception PropertyNotDefinedForType(object p0, object p1) {
            return new ArgumentException(Strings.PropertyNotDefinedForType(p0, p1));
        }

        /// <summary>
        /// ArgumentException with message like "Method '{0}' is not defined for type '{1}'"
        /// </summary>
        internal static Exception MethodNotDefinedForType(object p0, object p1) {
            return new ArgumentException(Strings.MethodNotDefinedForType(p0, p1));
        }

        /// <summary>
        /// ArgumentException with message like "Type {0} contains generic parameters"
        /// </summary>
        internal static Exception TypeContainsGenericParameters(object p0) {
            return new ArgumentException(Strings.TypeContainsGenericParameters(p0));
        }

        /// <summary>
        /// ArgumentException with message like "Type {0} is a generic type definition"
        /// </summary>
        internal static Exception TypeIsGeneric(object p0) {
            return new ArgumentException(Strings.TypeIsGeneric(p0));
        }

        /// <summary>
        /// ArgumentException with message like "Type '{0}' does not have a default constructor"
        /// </summary>
        internal static Exception TypeMissingDefaultConstructor(object p0) {
            return new ArgumentException(Strings.TypeMissingDefaultConstructor(p0));
        }

        /// <summary>
        /// ArgumentException with message like "List initializers must contain at least one initializer"
        /// </summary>
        internal static Exception ListInitializerWithZeroMembers() {
            return new ArgumentException(Strings.ListInitializerWithZeroMembers);
        }

        /// <summary>
        /// ArgumentException with message like "Element initializer method must be named 'Add'"
        /// </summary>
        internal static Exception ElementInitializerMethodNotAdd() {
            return new ArgumentException(Strings.ElementInitializerMethodNotAdd);
        }

        /// <summary>
        /// ArgumentException with message like "Parameter '{0}' of element initializer method '{1}' must not be a pass by reference parameter"
        /// </summary>
        internal static Exception ElementInitializerMethodNoRefOutParam(object p0, object p1) {
            return new ArgumentException(Strings.ElementInitializerMethodNoRefOutParam(p0, p1));
        }

        /// <summary>
        /// ArgumentException with message like "Element initializer method must have at least 1 parameter"
        /// </summary>
        internal static Exception ElementInitializerMethodWithZeroArgs() {
            return new ArgumentException(Strings.ElementInitializerMethodWithZeroArgs);
        }

        /// <summary>
        /// ArgumentException with message like "Element initializer method must be an instance method"
        /// </summary>
        internal static Exception ElementInitializerMethodStatic() {
            return new ArgumentException(Strings.ElementInitializerMethodStatic);
        }

        /// <summary>
        /// ArgumentException with message like "Type '{0}' is not IEnumerable"
        /// </summary>
        internal static Exception TypeNotIEnumerable(object p0) {
            return new ArgumentException(Strings.TypeNotIEnumerable(p0));
        }

        /// <summary>
        /// InvalidOperationException with message like "Type parameter is {0}. Expected a delegate."
        /// </summary>
        internal static Exception TypeParameterIsNotDelegate(object p0) {
            return new InvalidOperationException(Strings.TypeParameterIsNotDelegate(p0));
        }

        /// <summary>
        /// InvalidOperationException with message like "Unexpected coalesce operator."
        /// </summary>
        internal static Exception UnexpectedCoalesceOperator() {
            return new InvalidOperationException(Strings.UnexpectedCoalesceOperator);
        }

        /// <summary>
        /// InvalidOperationException with message like "Cannot cast from type '{0}' to type '{1}"
        /// </summary>
        internal static Exception InvalidCast(object p0, object p1) {
            return new InvalidOperationException(Strings.InvalidCast(p0, p1));
        }

        /// <summary>
        /// ArgumentException with message like "Unhandled binary: {0}"
        /// </summary>
        internal static Exception UnhandledBinary(object p0) {
            return new ArgumentException(Strings.UnhandledBinary(p0));
        }

        /// <summary>
        /// ArgumentException with message like "Unhandled binding "
        /// </summary>
        internal static Exception UnhandledBinding() {
            return new ArgumentException(Strings.UnhandledBinding);
        }

        /// <summary>
        /// ArgumentException with message like "Unhandled Binding Type: {0}"
        /// </summary>
        internal static Exception UnhandledBindingType(object p0) {
            return new ArgumentException(Strings.UnhandledBindingType(p0));
        }

        /// <summary>
        /// ArgumentException with message like "Unhandled convert: {0}"
        /// </summary>
        internal static Exception UnhandledConvert(object p0) {
            return new ArgumentException(Strings.UnhandledConvert(p0));
        }

        /// <summary>
        /// ArgumentException with message like "Unhandled Expression Type: {0}"
        /// </summary>
        internal static Exception UnhandledExpressionType(object p0) {
            return new ArgumentException(Strings.UnhandledExpressionType(p0));
        }

        /// <summary>
        /// ArgumentException with message like "Unhandled unary: {0}"
        /// </summary>
        internal static Exception UnhandledUnary(object p0) {
            return new ArgumentException(Strings.UnhandledUnary(p0));
        }

        /// <summary>
        /// ArgumentException with message like "Unknown binding type"
        /// </summary>
        internal static Exception UnknownBindingType() {
            return new ArgumentException(Strings.UnknownBindingType);
        }

        /// <summary>
        /// ArgumentException with message like "The user-defined operator method '{1}' for operator '{0}' must have identical parameter and return types."
        /// </summary>
        internal static Exception LogicalOperatorMustHaveConsistentTypes(object p0, object p1) {
            return new ArgumentException(Strings.LogicalOperatorMustHaveConsistentTypes(p0, p1));
        }

        /// <summary>
        /// ArgumentException with message like "The user-defined operator method '{1}' for operator '{0}' must have associated boolean True and False operators."
        /// </summary>
        internal static Exception LogicalOperatorMustHaveBooleanOperators(object p0, object p1) {
            return new ArgumentException(Strings.LogicalOperatorMustHaveBooleanOperators(p0, p1));
        }

        /// <summary>
        /// InvalidOperationException with message like "No method '{0}' exists on type '{1}'."
        /// </summary>
        internal static Exception MethodDoesNotExistOnType(object p0, object p1) {
            return new InvalidOperationException(Strings.MethodDoesNotExistOnType(p0, p1));
        }

        /// <summary>
        /// InvalidOperationException with message like "No method '{0}' on type '{1}' is compatible with the supplied arguments."
        /// </summary>
        internal static Exception MethodWithArgsDoesNotExistOnType(object p0, object p1) {
            return new InvalidOperationException(Strings.MethodWithArgsDoesNotExistOnType(p0, p1));
        }

        /// <summary>
        /// InvalidOperationException with message like "More than one method '{0}' on type '{1}' is compatible with the supplied arguments."
        /// </summary>
        internal static Exception MethodWithMoreThanOneMatch(object p0, object p1) {
            return new InvalidOperationException(Strings.MethodWithMoreThanOneMatch(p0, p1));
        }

        /// <summary>
        /// ArgumentException with message like "An incorrect number of type args were specified for the declaration of a Func type."
        /// </summary>
        internal static Exception IncorrectNumberOfTypeArgsForFunc() {
            return new ArgumentException(Strings.IncorrectNumberOfTypeArgsForFunc);
        }

        /// <summary>
        /// ArgumentException with message like "An incorrect number of type args were specified for the declaration of an Action type."
        /// </summary>
        internal static Exception IncorrectNumberOfTypeArgsForAction() {
            return new ArgumentException(Strings.IncorrectNumberOfTypeArgsForAction);
        }

        /// <summary>
        /// ArgumentException with message like "A lambda expression cannot contain pass by reference parameters."
        /// </summary>
        internal static Exception ExpressionMayNotContainByrefParameters() {
            return new ArgumentException(Strings.ExpressionMayNotContainByrefParameters);
        }

        /// <summary>
        /// ArgumentException with message like "Argument type cannot be System.Void."
        /// </summary>
        internal static Exception ArgumentCannotBeOfTypeVoid() {
            return new ArgumentException(Strings.ArgumentCannotBeOfTypeVoid);
        }

        /// <summary>
        /// InvalidOperationException with message like "No or Invalid rule produced"
        /// </summary>
        internal static Exception NoOrInvalidRuleProduced() {
            return new InvalidOperationException(Strings.NoOrInvalidRuleProduced);
        }

        /// <summary>
        /// InvalidOperationException with message like "RuleBuilder can only be used with delegates whose first argument is CallSite."
        /// </summary>
        internal static Exception FirstArgumentMustBeCallSite() {
            return new InvalidOperationException(Strings.FirstArgumentMustBeCallSite);
        }

        /// <summary>
        /// InvalidOperationException with message like "Bind cannot return null."
        /// </summary>
        internal static Exception BindingCannotBeNull() {
            return new InvalidOperationException(Strings.BindingCannotBeNull);
        }

        /// <summary>
        /// InvalidOperationException with message like "Empty rule set does not have target."
        /// </summary>
        internal static Exception EmptyRuleSetTarget() {
            return new InvalidOperationException(Strings.EmptyRuleSetTarget);
        }

        /// <summary>
        /// ArgumentException with message like "Left side of assignment is not an assignable node type."
        /// </summary>
        internal static Exception LhsUnassignable() {
            return new ArgumentException(Strings.LhsUnassignable);
        }

        /// <summary>
        /// InvalidOperationException with message like "Bad data bound to delegate."
        /// </summary>
        internal static Exception BadDelegateData() {
            return new InvalidOperationException(Strings.BadDelegateData);
        }

        /// <summary>
        /// ArgumentException with message like "Elements must be variables or parameters: {0}"
        /// </summary>
        internal static Exception MustBeVariableOrParameter(object p0) {
            return new ArgumentException(Strings.MustBeVariableOrParameter(p0));
        }

        /// <summary>
        /// ArgumentException with message like "Argument count (including instance) '{0}' must match arguments in the binding information '{1}'"
        /// </summary>
        internal static Exception ArgumentCountMustMatchBinding(object p0, object p1) {
            return new ArgumentException(Strings.ArgumentCountMustMatchBinding(p0, p1));
        }

        /// <summary>
        /// ArgumentException with message like "Invalid operation: '{0}'"
        /// </summary>
        internal static Exception InvalidOperation(object p0) {
            return new ArgumentException(Strings.InvalidOperation(p0));
        }

        /// <summary>
        /// ArgumentOutOfRangeException with message like "{0} must be greater than or equal to {1}"
        /// </summary>
        internal static Exception OutOfRange(object p0, object p1) {
            return new ArgumentOutOfRangeException(Strings.OutOfRange(p0, p1));
        }

        /// <summary>
        /// InvalidOperationException with message like "Removing an event handler that is not registered."
        /// </summary>
        internal static Exception RemovingUnregisteredEvent() {
            return new InvalidOperationException(Strings.RemovingUnregisteredEvent);
        }

        /// <summary>
        /// ArgumentException with message like "COM object does not support events."
        /// </summary>
        internal static Exception COMObjectDoesNotSupportEvents() {
            return new ArgumentException(Strings.COMObjectDoesNotSupportEvents);
        }

        /// <summary>
        /// ArgumentException with message like "COM object does not support specified source interface."
        /// </summary>
        internal static Exception COMObjectDoesNotSupportSourceInterface() {
            return new ArgumentException(Strings.COMObjectDoesNotSupportSourceInterface);
        }

        /// <summary>
        /// InvalidOperationException with message like "Removing not registered handler."
        /// </summary>
        internal static Exception RemovingUnregisteredHandler() {
            return new InvalidOperationException(Strings.RemovingUnregisteredHandler);
        }

        #if !SILVERLIGHT
        /// <summary>
        /// System.Runtime.InteropServices.COMException with message like "Marshal.SetComObjectData failed."
        /// </summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2201:DoNotRaiseReservedExceptionTypes")]
        internal static Exception SetComObjectDataFailed() {
            return new System.Runtime.InteropServices.COMException(Strings.SetComObjectDataFailed);
        }
        #endif

        #if !SILVERLIGHT
        /// <summary>
        /// System.Runtime.InteropServices.COMException with message like "TypeLib '{0}' does not contain COM interface '{1}'."
        /// </summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2201:DoNotRaiseReservedExceptionTypes")]
        internal static Exception TypeLibDoesNotContainInterface(object p0, object p1) {
            return new System.Runtime.InteropServices.COMException(Strings.TypeLibDoesNotContainInterface(p0, p1));
        }
        #endif

        /// <summary>
        /// InvalidOperationException with message like "This method exists only to keep the compiler happy."
        /// </summary>
        internal static Exception MethodShouldNotBeCalled() {
            return new InvalidOperationException(Strings.MethodShouldNotBeCalled);
        }

        /// <summary>
        /// InvalidProgramException with message like "Default value of COM parameter cannot be read properly."
        /// </summary>
        internal static Exception DefaultValueCannotBeRead() {
            return new InvalidProgramException(Strings.DefaultValueCannotBeRead);
        }

        /// <summary>
        /// InvalidOperationException with message like "Unexpected VarEnum {0}."
        /// </summary>
        internal static Exception UnexpectedVarEnum(object p0) {
            return new InvalidOperationException(Strings.UnexpectedVarEnum(p0));
        }

        /// <summary>
        /// System.Reflection.TargetParameterCountException with message like "Error while invoking {0}."
        /// </summary>
        internal static Exception DispBadParamCount(object p0) {
            return new System.Reflection.TargetParameterCountException(Strings.DispBadParamCount(p0));
        }

        /// <summary>
        /// MissingMemberException with message like "Error while invoking {0}."
        /// </summary>
        internal static Exception DispMemberNotFound(object p0) {
            return new MissingMemberException(Strings.DispMemberNotFound(p0));
        }

        /// <summary>
        /// ArgumentException with message like "Error while invoking {0}. Named arguments are not supported."
        /// </summary>
        internal static Exception DispNoNamedArgs(object p0) {
            return new ArgumentException(Strings.DispNoNamedArgs(p0));
        }

        /// <summary>
        /// OverflowException with message like "Error while invoking {0}."
        /// </summary>
        internal static Exception DispOverflow(object p0) {
            return new OverflowException(Strings.DispOverflow(p0));
        }

        /// <summary>
        /// System.Scripting.ArgumentTypeException with message like "Could not convert argument {0} for call to {1}."
        /// </summary>
        internal static Exception DispTypeMismatch(object p0, object p1) {
            return new System.Scripting.ArgumentTypeException(Strings.DispTypeMismatch(p0, p1));
        }

        /// <summary>
        /// ArgumentException with message like "Error while invoking {0}. A required parameter was omitted."
        /// </summary>
        internal static Exception DispParamNotOptional(object p0) {
            return new ArgumentException(Strings.DispParamNotOptional(p0));
        }

        #if !SILVERLIGHT
        /// <summary>
        /// System.Runtime.InteropServices.COMException with message like "ResolveComReference.CannotRetrieveTypeInformation."
        /// </summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2201:DoNotRaiseReservedExceptionTypes")]
        internal static Exception CannotRetrieveTypeInformation() {
            return new System.Runtime.InteropServices.COMException(Strings.CannotRetrieveTypeInformation);
        }
        #endif

        /// <summary>
        /// System.Scripting.InvalidImplementationException with message like "IDispatch::GetIDsOfNames behaved unexpectedly for {0}."
        /// </summary>
        internal static Exception GetIDsOfNamesInvalid(object p0) {
            return new System.Scripting.InvalidImplementationException(Strings.GetIDsOfNamesInvalid(p0));
        }

        /// <summary>
        /// InvalidOperationException with message like "Attempting to wrap an unsupported enum type."
        /// </summary>
        internal static Exception UnsupportedEnumType() {
            return new InvalidOperationException(Strings.UnsupportedEnumType);
        }

        /// <summary>
        /// ArgumentException with message like "COM object is expected."
        /// </summary>
        internal static Exception ComObjectExpected() {
            return new ArgumentException(Strings.ComObjectExpected);
        }

        /// <summary>
        /// MissingMemberException with message like "Could not get DispId for {0} (error:{1})."
        /// </summary>
        internal static Exception CouldNotGetDispId(object p0, object p1) {
            return new MissingMemberException(Strings.CouldNotGetDispId(p0, p1));
        }

        /// <summary>
        /// System.Reflection.AmbiguousMatchException with message like "There are valid conversions from {0} to {1}."
        /// </summary>
        internal static Exception AmbiguousConversion(object p0, object p1) {
            return new System.Reflection.AmbiguousMatchException(Strings.AmbiguousConversion(p0, p1));
        }

        /// <summary>
        /// NotImplementedException with message like "Variant.ToObject cannot handle {0}."
        /// </summary>
        internal static Exception VariantToObjectNYI(object p0) {
            return new NotImplementedException(Strings.VariantToObjectNYI(p0));
        }

        /// <summary>
        /// NotImplementedException with message like "Variant.GetAccessor cannot handle {0}."
        /// </summary>
        internal static Exception VariantGetAccessorNYI(object p0) {
            return new NotImplementedException(Strings.VariantGetAccessorNYI(p0));
        }

        /// <summary>
        /// InvalidOperationException with message like "Queue empty."
        /// </summary>
        internal static Exception QueueEmpty() {
            return new InvalidOperationException(Strings.QueueEmpty);
        }

        /// <summary>
        /// NotSupportedException with message like "Cannot emit address of void-typed block."
        /// </summary>
        internal static Exception AddressOfVoidBlock() {
            return new NotSupportedException(Strings.AddressOfVoidBlock);
        }

        /// <summary>
        /// InvalidOperationException with message like "Statement not on the stack."
        /// </summary>
        internal static Exception StatementNotOnStack() {
            return new InvalidOperationException(Strings.StatementNotOnStack);
        }

        /// <summary>
        /// InvalidOperationException with message like "Dynamic expression not reduced."
        /// </summary>
        internal static Exception DynamicNotReduced() {
            return new InvalidOperationException(Strings.DynamicNotReduced);
        }

        /// <summary>
        /// InvalidOperationException with message like "Action should have been reduced."
        /// </summary>
        internal static Exception ActionNotReduced() {
            return new InvalidOperationException(Strings.ActionNotReduced);
        }

        /// <summary>
        /// InvalidOperationException with message like "Delete should have been reduced."
        /// </summary>
        internal static Exception DeleteNotReduced() {
            return new InvalidOperationException(Strings.DeleteNotReduced);
        }

        /// <summary>
        /// InvalidOperationException with message like "Extension should have been reduced."
        /// </summary>
        internal static Exception ExtensionNotReduced() {
            return new InvalidOperationException(Strings.ExtensionNotReduced);
        }

        /// <summary>
        /// InvalidOperationException with message like "Runtime constants require a bound delegate."
        /// </summary>
        internal static Exception RtConstRequiresBundDelegate() {
            return new InvalidOperationException(Strings.RtConstRequiresBundDelegate);
        }

        /// <summary>
        /// InvalidOperationException with message like "Invalid lvalue for assignment: {0}."
        /// </summary>
        internal static Exception InvalidLvalue(object p0) {
            return new InvalidOperationException(Strings.InvalidLvalue(p0));
        }

        /// <summary>
        /// InvalidOperationException with message like "Invalid member type: {0}."
        /// </summary>
        internal static Exception InvalidMemberType(object p0) {
            return new InvalidOperationException(Strings.InvalidMemberType(p0));
        }

        /// <summary>
        /// InvalidOperationException with message like "unknown lift type: '{0}'."
        /// </summary>
        internal static Exception UnknownLiftType(object p0) {
            return new InvalidOperationException(Strings.UnknownLiftType(p0));
        }

        /// <summary>
        /// ArgumentException with message like "Invalid output directory."
        /// </summary>
        internal static Exception InvalidOutputDir() {
            return new ArgumentException(Strings.InvalidOutputDir);
        }

        /// <summary>
        /// ArgumentException with message like "Invalid assembly name or file extension."
        /// </summary>
        internal static Exception InvalidAsmNameOrExtension() {
            return new ArgumentException(Strings.InvalidAsmNameOrExtension);
        }

        /// <summary>
        /// ArgumentException with message like "Cannot emit constant {0} ({1})"
        /// </summary>
        internal static Exception CanotEmitConstant(object p0, object p1) {
            return new ArgumentException(Strings.CanotEmitConstant(p0, p1));
        }

        /// <summary>
        /// ArgumentException with message like "No implicit cast from {0} to {1}"
        /// </summary>
        internal static Exception NoImplicitCast(object p0, object p1) {
            return new ArgumentException(Strings.NoImplicitCast(p0, p1));
        }

        /// <summary>
        /// ArgumentException with message like "No explicit cast from {0} to {1}"
        /// </summary>
        internal static Exception NoExplicitCast(object p0, object p1) {
            return new ArgumentException(Strings.NoExplicitCast(p0, p1));
        }

        /// <summary>
        /// ArgumentException with message like "No default value for a given type."
        /// </summary>
        internal static Exception NoDefaultValue() {
            return new ArgumentException(Strings.NoDefaultValue);
        }

        /// <summary>
        /// InvalidOperationException with message like "Stack changed while enumerating."
        /// </summary>
        internal static Exception StackChangedWhileEnumerationg() {
            return new InvalidOperationException(Strings.StackChangedWhileEnumerationg);
        }

        /// <summary>
        /// NotSupportedException with message like "Collection is read-only."
        /// </summary>
        internal static Exception CollectionReadOnly() {
            return new NotSupportedException(Strings.CollectionReadOnly);
        }

        /// <summary>
        /// InvalidOperationException with message like "can't read from property"
        /// </summary>
        internal static Exception CantReadProperty() {
            return new InvalidOperationException(Strings.CantReadProperty);
        }

        /// <summary>
        /// InvalidOperationException with message like "can't write to property"
        /// </summary>
        internal static Exception CantWriteProperty() {
            return new InvalidOperationException(Strings.CantWriteProperty);
        }

        /// <summary>
        /// ArgumentException with message like "Cannot create instance of {0} because it contains generic parameters"
        /// </summary>
        internal static Exception IllegalNew_GenericParams(object p0) {
            return new ArgumentException(Strings.IllegalNew_GenericParams(p0));
        }

        /// <summary>
        /// System.Security.VerificationException with message like "Non-verifiable assembly generated: {0}:\nAssembly preserved as {1}\nError text:\n{2}\n"
        /// </summary>
        internal static Exception VerificationException(object p0, object p1, object p2) {
            return new System.Security.VerificationException(Strings.VerificationException(p0, p1, p2));
        }

        /// <summary>
        /// InvalidOperationException with message like "Variable '{0}' referenced from lambda '{1}', but it is not defined in an outer scope"
        /// </summary>
        internal static Exception UnboundVariable(object p0, object p1) {
            return new InvalidOperationException(Strings.UnboundVariable(p0, p1));
        }

        /// <summary>
        /// InvalidOperationException with message like "yield outside of generator in lambda '{0}'"
        /// </summary>
        internal static Exception YieldOutsideOfGenerator(object p0) {
            return new InvalidOperationException(Strings.YieldOutsideOfGenerator(p0));
        }

        /// <summary>
        /// InvalidOperationException with message like "Expression of type '{0}' cannot be used for return type '{1}' of lambda '{2}'"
        /// </summary>
        internal static Exception InvalidReturnTypeOfLambda(object p0, object p1, object p2) {
            return new InvalidOperationException(Strings.InvalidReturnTypeOfLambda(p0, p1, p2));
        }

        /// <summary>
        /// InvalidOperationException with message like "Expression missing for return in lambda '{0}', must have return type '{1}'"
        /// </summary>
        internal static Exception MissingReturnForLambda(object p0, object p1) {
            return new InvalidOperationException(Strings.MissingReturnForLambda(p0, p1));
        }

        /// <summary>
        /// InvalidOperationException with message like "Cannot close over byref parameter '{0}' referenced in lambda '{1}'"
        /// </summary>
        internal static Exception CannotCloseOverByRef(object p0, object p1) {
            return new InvalidOperationException(Strings.CannotCloseOverByRef(p0, p1));
        }

        /// <summary>
        /// System.Scripting.ArgumentTypeException with message like "Expected type {0}, got {1}."
        /// </summary>
        internal static Exception UnexpectedType(object p0, object p1) {
            return new System.Scripting.ArgumentTypeException(Strings.UnexpectedType(p0, p1));
        }

    }

    // *** END GENERATED CODE ***

    #endregion

}
