/* ****************************************************************************
 *
 * Copyright (c) Microsoft Corporation. 
 *
 * This source code is subject to terms and conditions of the Microsoft Public License. A 
 * copy of the license can be found in the License.html file at the root of this distribution. If 
 * you cannot locate the  Microsoft Public License, please send an email to 
 * dlr@microsoft.com. By using this source code in any fashion, you are agreeing to be bound 
 * by the terms of the Microsoft Public License.
 *
 * You must not remove this notice, or any other, from this software.
 *
 *
 * ***************************************************************************/
using System; using Microsoft;
using System.Runtime.CompilerServices;
using Microsoft.Runtime.CompilerServices;
using System.Threading;

namespace Microsoft.Scripting.Actions {
    internal static partial class UpdateDelegates {

        //
        // WARNING: do not edit these methods here. The real source code lives
        // in two places: generate_dynsites.py, which generates the methods in
        // this file, and UpdateDelegates.cs, which dynamically generates
        // methods like these at run time. If you want to make a change, edit
        // *both* of those files instead
        //

        #region Generated UpdateAndExecute Methods

        // *** BEGIN GENERATED CODE ***
        // generated by function: gen_update_targets from: generate_dynsites.py


        [Obsolete("pregenerated CallSite<T>.Update delegate", true)]
        internal static TRet UpdateAndExecute1<T0, TRet>(CallSite site, T0 arg0) {
            //
            // Declare the locals here upfront. It actually saves JIT stack space.
            //
            var @this = (CallSite<Func<CallSite, T0, TRet>>)site;
            CallSiteRule<Func<CallSite, T0, TRet>>[] applicable;
            CallSiteRule<Func<CallSite, T0, TRet>> rule;
            Func<CallSite, T0, TRet> ruleTarget, startingTarget = @this.Target;
            TRet result;

            int count, index;
            CallSiteRule<Func<CallSite, T0, TRet>> originalRule = null;

            //
            // Create matchmaker and its site. We'll need them regardless.
            //
            bool match = true;
            site = CallSiteOps.CreateMatchmaker(
                @this,
                (mm_site, mm_arg0) => {
                    match = false;
                    return default(TRet);
                }
            );

            //
            // Level 1 cache lookup
            //
            if ((applicable = CallSiteOps.GetRules(@this)) != null) {
                for (index = 0, count = applicable.Length; index < count; index++) {
                    rule = applicable[index];

                    //
                    // Execute the rule
                    //
                    ruleTarget = CallSiteOps.SetTarget(@this, rule);

                    try {
                        result = ruleTarget(site, arg0);
                        if (match) {
                            return result;
                        }
                    } finally {
                        if (match) {
                            //
                            // Match in Level 1 cache. We saw the arguments that match the rule before and now we
                            // see them again. The site is polymorphic. Update the delegate and keep running
                            //
                            CallSiteOps.SetPolymorphicTarget(@this);
                        }
                    }

                    if (startingTarget == ruleTarget) {
                        // our rule was previously monomorphic, if we produce another monomorphic
                        // rule we should try and share code between the two.
                        originalRule = rule;
                    }

                    // Rule didn't match, try the next one
                    match = true;            
                }
            }

            //
            // Level 2 cache lookup
            //
            var args = new object[] { arg0 };

            //
            // Any applicable rules in level 2 cache?
            //
            if ((applicable = CallSiteOps.FindApplicableRules(@this, args)) != null) {
                for (index = 0, count = applicable.Length; index < count; index++) {
                    rule = applicable[index];

                    //
                    // Execute the rule
                    //
                    ruleTarget = CallSiteOps.SetTarget(@this, rule);

                    try {
                        result = ruleTarget(site, arg0);
                        if (match) {
                            return result;
                        }
                    } finally {
                        if (match) {
                            //
                            // Rule worked. Add it to level 1 cache
                            //
                            CallSiteOps.AddRule(@this, rule);
                        }
                    }

                    if (startingTarget == ruleTarget) {
                        // If we've gone megamorphic we can still template off the L2 cache
                        originalRule = rule;
                    }

                    // Rule didn't match, try the next one
                    match = true;
                }
            }


            //
            // Miss on Level 0, 1 and 2 caches. Create new rule
            //

            rule = null;

            for (; ; ) {
                rule = CallSiteOps.CreateNewRule(@this, rule, originalRule, args);

                //
                // Execute the rule on the matchmaker site
                //

                ruleTarget = CallSiteOps.SetTarget(@this, rule);

                try {
                    result = ruleTarget(site, arg0);
                    if (match) {
                        return result;
                    }
                } finally {
                    if (match) {
                        //
                        // The rule worked. Add it to level 1 cache.
                        //
                        CallSiteOps.AddRule(@this, rule);
                    }
                }

                // Rule we got back didn't work, try another one
                match = true;
            }
        }


        [Obsolete("pregenerated CallSite<T>.Update delegate", true)]
        internal static TRet UpdateAndExecute2<T0, T1, TRet>(CallSite site, T0 arg0, T1 arg1) {
            //
            // Declare the locals here upfront. It actually saves JIT stack space.
            //
            var @this = (CallSite<Func<CallSite, T0, T1, TRet>>)site;
            CallSiteRule<Func<CallSite, T0, T1, TRet>>[] applicable;
            CallSiteRule<Func<CallSite, T0, T1, TRet>> rule;
            Func<CallSite, T0, T1, TRet> ruleTarget, startingTarget = @this.Target;
            TRet result;

            int count, index;
            CallSiteRule<Func<CallSite, T0, T1, TRet>> originalRule = null;

            //
            // Create matchmaker and its site. We'll need them regardless.
            //
            bool match = true;
            site = CallSiteOps.CreateMatchmaker(
                @this,
                (mm_site, mm_arg0, mm_arg1) => {
                    match = false;
                    return default(TRet);
                }
            );

            //
            // Level 1 cache lookup
            //
            if ((applicable = CallSiteOps.GetRules(@this)) != null) {
                for (index = 0, count = applicable.Length; index < count; index++) {
                    rule = applicable[index];

                    //
                    // Execute the rule
                    //
                    ruleTarget = CallSiteOps.SetTarget(@this, rule);

                    try {
                        result = ruleTarget(site, arg0, arg1);
                        if (match) {
                            return result;
                        }
                    } finally {
                        if (match) {
                            //
                            // Match in Level 1 cache. We saw the arguments that match the rule before and now we
                            // see them again. The site is polymorphic. Update the delegate and keep running
                            //
                            CallSiteOps.SetPolymorphicTarget(@this);
                        }
                    }

                    if (startingTarget == ruleTarget) {
                        // our rule was previously monomorphic, if we produce another monomorphic
                        // rule we should try and share code between the two.
                        originalRule = rule;
                    }

                    // Rule didn't match, try the next one
                    match = true;            
                }
            }

            //
            // Level 2 cache lookup
            //
            var args = new object[] { arg0, arg1 };

            //
            // Any applicable rules in level 2 cache?
            //
            if ((applicable = CallSiteOps.FindApplicableRules(@this, args)) != null) {
                for (index = 0, count = applicable.Length; index < count; index++) {
                    rule = applicable[index];

                    //
                    // Execute the rule
                    //
                    ruleTarget = CallSiteOps.SetTarget(@this, rule);

                    try {
                        result = ruleTarget(site, arg0, arg1);
                        if (match) {
                            return result;
                        }
                    } finally {
                        if (match) {
                            //
                            // Rule worked. Add it to level 1 cache
                            //
                            CallSiteOps.AddRule(@this, rule);
                        }
                    }

                    if (startingTarget == ruleTarget) {
                        // If we've gone megamorphic we can still template off the L2 cache
                        originalRule = rule;
                    }

                    // Rule didn't match, try the next one
                    match = true;
                }
            }


            //
            // Miss on Level 0, 1 and 2 caches. Create new rule
            //

            rule = null;

            for (; ; ) {
                rule = CallSiteOps.CreateNewRule(@this, rule, originalRule, args);

                //
                // Execute the rule on the matchmaker site
                //

                ruleTarget = CallSiteOps.SetTarget(@this, rule);

                try {
                    result = ruleTarget(site, arg0, arg1);
                    if (match) {
                        return result;
                    }
                } finally {
                    if (match) {
                        //
                        // The rule worked. Add it to level 1 cache.
                        //
                        CallSiteOps.AddRule(@this, rule);
                    }
                }

                // Rule we got back didn't work, try another one
                match = true;
            }
        }


        [Obsolete("pregenerated CallSite<T>.Update delegate", true)]
        internal static TRet UpdateAndExecute3<T0, T1, T2, TRet>(CallSite site, T0 arg0, T1 arg1, T2 arg2) {
            //
            // Declare the locals here upfront. It actually saves JIT stack space.
            //
            var @this = (CallSite<Func<CallSite, T0, T1, T2, TRet>>)site;
            CallSiteRule<Func<CallSite, T0, T1, T2, TRet>>[] applicable;
            CallSiteRule<Func<CallSite, T0, T1, T2, TRet>> rule;
            Func<CallSite, T0, T1, T2, TRet> ruleTarget, startingTarget = @this.Target;
            TRet result;

            int count, index;
            CallSiteRule<Func<CallSite, T0, T1, T2, TRet>> originalRule = null;

            //
            // Create matchmaker and its site. We'll need them regardless.
            //
            bool match = true;
            site = CallSiteOps.CreateMatchmaker(
                @this,
                (mm_site, mm_arg0, mm_arg1, mm_arg2) => {
                    match = false;
                    return default(TRet);
                }
            );

            //
            // Level 1 cache lookup
            //
            if ((applicable = CallSiteOps.GetRules(@this)) != null) {
                for (index = 0, count = applicable.Length; index < count; index++) {
                    rule = applicable[index];

                    //
                    // Execute the rule
                    //
                    ruleTarget = CallSiteOps.SetTarget(@this, rule);

                    try {
                        result = ruleTarget(site, arg0, arg1, arg2);
                        if (match) {
                            return result;
                        }
                    } finally {
                        if (match) {
                            //
                            // Match in Level 1 cache. We saw the arguments that match the rule before and now we
                            // see them again. The site is polymorphic. Update the delegate and keep running
                            //
                            CallSiteOps.SetPolymorphicTarget(@this);
                        }
                    }

                    if (startingTarget == ruleTarget) {
                        // our rule was previously monomorphic, if we produce another monomorphic
                        // rule we should try and share code between the two.
                        originalRule = rule;
                    }

                    // Rule didn't match, try the next one
                    match = true;            
                }
            }

            //
            // Level 2 cache lookup
            //
            var args = new object[] { arg0, arg1, arg2 };

            //
            // Any applicable rules in level 2 cache?
            //
            if ((applicable = CallSiteOps.FindApplicableRules(@this, args)) != null) {
                for (index = 0, count = applicable.Length; index < count; index++) {
                    rule = applicable[index];

                    //
                    // Execute the rule
                    //
                    ruleTarget = CallSiteOps.SetTarget(@this, rule);

                    try {
                        result = ruleTarget(site, arg0, arg1, arg2);
                        if (match) {
                            return result;
                        }
                    } finally {
                        if (match) {
                            //
                            // Rule worked. Add it to level 1 cache
                            //
                            CallSiteOps.AddRule(@this, rule);
                        }
                    }

                    if (startingTarget == ruleTarget) {
                        // If we've gone megamorphic we can still template off the L2 cache
                        originalRule = rule;
                    }

                    // Rule didn't match, try the next one
                    match = true;
                }
            }


            //
            // Miss on Level 0, 1 and 2 caches. Create new rule
            //

            rule = null;

            for (; ; ) {
                rule = CallSiteOps.CreateNewRule(@this, rule, originalRule, args);

                //
                // Execute the rule on the matchmaker site
                //

                ruleTarget = CallSiteOps.SetTarget(@this, rule);

                try {
                    result = ruleTarget(site, arg0, arg1, arg2);
                    if (match) {
                        return result;
                    }
                } finally {
                    if (match) {
                        //
                        // The rule worked. Add it to level 1 cache.
                        //
                        CallSiteOps.AddRule(@this, rule);
                    }
                }

                // Rule we got back didn't work, try another one
                match = true;
            }
        }


        [Obsolete("pregenerated CallSite<T>.Update delegate", true)]
        internal static TRet UpdateAndExecute4<T0, T1, T2, T3, TRet>(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3) {
            //
            // Declare the locals here upfront. It actually saves JIT stack space.
            //
            var @this = (CallSite<Func<CallSite, T0, T1, T2, T3, TRet>>)site;
            CallSiteRule<Func<CallSite, T0, T1, T2, T3, TRet>>[] applicable;
            CallSiteRule<Func<CallSite, T0, T1, T2, T3, TRet>> rule;
            Func<CallSite, T0, T1, T2, T3, TRet> ruleTarget, startingTarget = @this.Target;
            TRet result;

            int count, index;
            CallSiteRule<Func<CallSite, T0, T1, T2, T3, TRet>> originalRule = null;

            //
            // Create matchmaker and its site. We'll need them regardless.
            //
            bool match = true;
            site = CallSiteOps.CreateMatchmaker(
                @this,
                (mm_site, mm_arg0, mm_arg1, mm_arg2, mm_arg3) => {
                    match = false;
                    return default(TRet);
                }
            );

            //
            // Level 1 cache lookup
            //
            if ((applicable = CallSiteOps.GetRules(@this)) != null) {
                for (index = 0, count = applicable.Length; index < count; index++) {
                    rule = applicable[index];

                    //
                    // Execute the rule
                    //
                    ruleTarget = CallSiteOps.SetTarget(@this, rule);

                    try {
                        result = ruleTarget(site, arg0, arg1, arg2, arg3);
                        if (match) {
                            return result;
                        }
                    } finally {
                        if (match) {
                            //
                            // Match in Level 1 cache. We saw the arguments that match the rule before and now we
                            // see them again. The site is polymorphic. Update the delegate and keep running
                            //
                            CallSiteOps.SetPolymorphicTarget(@this);
                        }
                    }

                    if (startingTarget == ruleTarget) {
                        // our rule was previously monomorphic, if we produce another monomorphic
                        // rule we should try and share code between the two.
                        originalRule = rule;
                    }

                    // Rule didn't match, try the next one
                    match = true;            
                }
            }

            //
            // Level 2 cache lookup
            //
            var args = new object[] { arg0, arg1, arg2, arg3 };

            //
            // Any applicable rules in level 2 cache?
            //
            if ((applicable = CallSiteOps.FindApplicableRules(@this, args)) != null) {
                for (index = 0, count = applicable.Length; index < count; index++) {
                    rule = applicable[index];

                    //
                    // Execute the rule
                    //
                    ruleTarget = CallSiteOps.SetTarget(@this, rule);

                    try {
                        result = ruleTarget(site, arg0, arg1, arg2, arg3);
                        if (match) {
                            return result;
                        }
                    } finally {
                        if (match) {
                            //
                            // Rule worked. Add it to level 1 cache
                            //
                            CallSiteOps.AddRule(@this, rule);
                        }
                    }

                    if (startingTarget == ruleTarget) {
                        // If we've gone megamorphic we can still template off the L2 cache
                        originalRule = rule;
                    }

                    // Rule didn't match, try the next one
                    match = true;
                }
            }


            //
            // Miss on Level 0, 1 and 2 caches. Create new rule
            //

            rule = null;

            for (; ; ) {
                rule = CallSiteOps.CreateNewRule(@this, rule, originalRule, args);

                //
                // Execute the rule on the matchmaker site
                //

                ruleTarget = CallSiteOps.SetTarget(@this, rule);

                try {
                    result = ruleTarget(site, arg0, arg1, arg2, arg3);
                    if (match) {
                        return result;
                    }
                } finally {
                    if (match) {
                        //
                        // The rule worked. Add it to level 1 cache.
                        //
                        CallSiteOps.AddRule(@this, rule);
                    }
                }

                // Rule we got back didn't work, try another one
                match = true;
            }
        }


        [Obsolete("pregenerated CallSite<T>.Update delegate", true)]
        internal static TRet UpdateAndExecute5<T0, T1, T2, T3, T4, TRet>(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4) {
            //
            // Declare the locals here upfront. It actually saves JIT stack space.
            //
            var @this = (CallSite<Func<CallSite, T0, T1, T2, T3, T4, TRet>>)site;
            CallSiteRule<Func<CallSite, T0, T1, T2, T3, T4, TRet>>[] applicable;
            CallSiteRule<Func<CallSite, T0, T1, T2, T3, T4, TRet>> rule;
            Func<CallSite, T0, T1, T2, T3, T4, TRet> ruleTarget, startingTarget = @this.Target;
            TRet result;

            int count, index;
            CallSiteRule<Func<CallSite, T0, T1, T2, T3, T4, TRet>> originalRule = null;

            //
            // Create matchmaker and its site. We'll need them regardless.
            //
            bool match = true;
            site = CallSiteOps.CreateMatchmaker(
                @this,
                (mm_site, mm_arg0, mm_arg1, mm_arg2, mm_arg3, mm_arg4) => {
                    match = false;
                    return default(TRet);
                }
            );

            //
            // Level 1 cache lookup
            //
            if ((applicable = CallSiteOps.GetRules(@this)) != null) {
                for (index = 0, count = applicable.Length; index < count; index++) {
                    rule = applicable[index];

                    //
                    // Execute the rule
                    //
                    ruleTarget = CallSiteOps.SetTarget(@this, rule);

                    try {
                        result = ruleTarget(site, arg0, arg1, arg2, arg3, arg4);
                        if (match) {
                            return result;
                        }
                    } finally {
                        if (match) {
                            //
                            // Match in Level 1 cache. We saw the arguments that match the rule before and now we
                            // see them again. The site is polymorphic. Update the delegate and keep running
                            //
                            CallSiteOps.SetPolymorphicTarget(@this);
                        }
                    }

                    if (startingTarget == ruleTarget) {
                        // our rule was previously monomorphic, if we produce another monomorphic
                        // rule we should try and share code between the two.
                        originalRule = rule;
                    }

                    // Rule didn't match, try the next one
                    match = true;            
                }
            }

            //
            // Level 2 cache lookup
            //
            var args = new object[] { arg0, arg1, arg2, arg3, arg4 };

            //
            // Any applicable rules in level 2 cache?
            //
            if ((applicable = CallSiteOps.FindApplicableRules(@this, args)) != null) {
                for (index = 0, count = applicable.Length; index < count; index++) {
                    rule = applicable[index];

                    //
                    // Execute the rule
                    //
                    ruleTarget = CallSiteOps.SetTarget(@this, rule);

                    try {
                        result = ruleTarget(site, arg0, arg1, arg2, arg3, arg4);
                        if (match) {
                            return result;
                        }
                    } finally {
                        if (match) {
                            //
                            // Rule worked. Add it to level 1 cache
                            //
                            CallSiteOps.AddRule(@this, rule);
                        }
                    }

                    if (startingTarget == ruleTarget) {
                        // If we've gone megamorphic we can still template off the L2 cache
                        originalRule = rule;
                    }

                    // Rule didn't match, try the next one
                    match = true;
                }
            }


            //
            // Miss on Level 0, 1 and 2 caches. Create new rule
            //

            rule = null;

            for (; ; ) {
                rule = CallSiteOps.CreateNewRule(@this, rule, originalRule, args);

                //
                // Execute the rule on the matchmaker site
                //

                ruleTarget = CallSiteOps.SetTarget(@this, rule);

                try {
                    result = ruleTarget(site, arg0, arg1, arg2, arg3, arg4);
                    if (match) {
                        return result;
                    }
                } finally {
                    if (match) {
                        //
                        // The rule worked. Add it to level 1 cache.
                        //
                        CallSiteOps.AddRule(@this, rule);
                    }
                }

                // Rule we got back didn't work, try another one
                match = true;
            }
        }


        [Obsolete("pregenerated CallSite<T>.Update delegate", true)]
        internal static TRet UpdateAndExecute6<T0, T1, T2, T3, T4, T5, TRet>(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5) {
            //
            // Declare the locals here upfront. It actually saves JIT stack space.
            //
            var @this = (CallSite<Func<CallSite, T0, T1, T2, T3, T4, T5, TRet>>)site;
            CallSiteRule<Func<CallSite, T0, T1, T2, T3, T4, T5, TRet>>[] applicable;
            CallSiteRule<Func<CallSite, T0, T1, T2, T3, T4, T5, TRet>> rule;
            Func<CallSite, T0, T1, T2, T3, T4, T5, TRet> ruleTarget, startingTarget = @this.Target;
            TRet result;

            int count, index;
            CallSiteRule<Func<CallSite, T0, T1, T2, T3, T4, T5, TRet>> originalRule = null;

            //
            // Create matchmaker and its site. We'll need them regardless.
            //
            bool match = true;
            site = CallSiteOps.CreateMatchmaker(
                @this,
                (mm_site, mm_arg0, mm_arg1, mm_arg2, mm_arg3, mm_arg4, mm_arg5) => {
                    match = false;
                    return default(TRet);
                }
            );

            //
            // Level 1 cache lookup
            //
            if ((applicable = CallSiteOps.GetRules(@this)) != null) {
                for (index = 0, count = applicable.Length; index < count; index++) {
                    rule = applicable[index];

                    //
                    // Execute the rule
                    //
                    ruleTarget = CallSiteOps.SetTarget(@this, rule);

                    try {
                        result = ruleTarget(site, arg0, arg1, arg2, arg3, arg4, arg5);
                        if (match) {
                            return result;
                        }
                    } finally {
                        if (match) {
                            //
                            // Match in Level 1 cache. We saw the arguments that match the rule before and now we
                            // see them again. The site is polymorphic. Update the delegate and keep running
                            //
                            CallSiteOps.SetPolymorphicTarget(@this);
                        }
                    }

                    if (startingTarget == ruleTarget) {
                        // our rule was previously monomorphic, if we produce another monomorphic
                        // rule we should try and share code between the two.
                        originalRule = rule;
                    }

                    // Rule didn't match, try the next one
                    match = true;            
                }
            }

            //
            // Level 2 cache lookup
            //
            var args = new object[] { arg0, arg1, arg2, arg3, arg4, arg5 };

            //
            // Any applicable rules in level 2 cache?
            //
            if ((applicable = CallSiteOps.FindApplicableRules(@this, args)) != null) {
                for (index = 0, count = applicable.Length; index < count; index++) {
                    rule = applicable[index];

                    //
                    // Execute the rule
                    //
                    ruleTarget = CallSiteOps.SetTarget(@this, rule);

                    try {
                        result = ruleTarget(site, arg0, arg1, arg2, arg3, arg4, arg5);
                        if (match) {
                            return result;
                        }
                    } finally {
                        if (match) {
                            //
                            // Rule worked. Add it to level 1 cache
                            //
                            CallSiteOps.AddRule(@this, rule);
                        }
                    }

                    if (startingTarget == ruleTarget) {
                        // If we've gone megamorphic we can still template off the L2 cache
                        originalRule = rule;
                    }

                    // Rule didn't match, try the next one
                    match = true;
                }
            }


            //
            // Miss on Level 0, 1 and 2 caches. Create new rule
            //

            rule = null;

            for (; ; ) {
                rule = CallSiteOps.CreateNewRule(@this, rule, originalRule, args);

                //
                // Execute the rule on the matchmaker site
                //

                ruleTarget = CallSiteOps.SetTarget(@this, rule);

                try {
                    result = ruleTarget(site, arg0, arg1, arg2, arg3, arg4, arg5);
                    if (match) {
                        return result;
                    }
                } finally {
                    if (match) {
                        //
                        // The rule worked. Add it to level 1 cache.
                        //
                        CallSiteOps.AddRule(@this, rule);
                    }
                }

                // Rule we got back didn't work, try another one
                match = true;
            }
        }


        [Obsolete("pregenerated CallSite<T>.Update delegate", true)]
        internal static TRet UpdateAndExecute7<T0, T1, T2, T3, T4, T5, T6, TRet>(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6) {
            //
            // Declare the locals here upfront. It actually saves JIT stack space.
            //
            var @this = (CallSite<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, TRet>>)site;
            CallSiteRule<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, TRet>>[] applicable;
            CallSiteRule<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, TRet>> rule;
            Func<CallSite, T0, T1, T2, T3, T4, T5, T6, TRet> ruleTarget, startingTarget = @this.Target;
            TRet result;

            int count, index;
            CallSiteRule<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, TRet>> originalRule = null;

            //
            // Create matchmaker and its site. We'll need them regardless.
            //
            bool match = true;
            site = CallSiteOps.CreateMatchmaker(
                @this,
                (mm_site, mm_arg0, mm_arg1, mm_arg2, mm_arg3, mm_arg4, mm_arg5, mm_arg6) => {
                    match = false;
                    return default(TRet);
                }
            );

            //
            // Level 1 cache lookup
            //
            if ((applicable = CallSiteOps.GetRules(@this)) != null) {
                for (index = 0, count = applicable.Length; index < count; index++) {
                    rule = applicable[index];

                    //
                    // Execute the rule
                    //
                    ruleTarget = CallSiteOps.SetTarget(@this, rule);

                    try {
                        result = ruleTarget(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6);
                        if (match) {
                            return result;
                        }
                    } finally {
                        if (match) {
                            //
                            // Match in Level 1 cache. We saw the arguments that match the rule before and now we
                            // see them again. The site is polymorphic. Update the delegate and keep running
                            //
                            CallSiteOps.SetPolymorphicTarget(@this);
                        }
                    }

                    if (startingTarget == ruleTarget) {
                        // our rule was previously monomorphic, if we produce another monomorphic
                        // rule we should try and share code between the two.
                        originalRule = rule;
                    }

                    // Rule didn't match, try the next one
                    match = true;            
                }
            }

            //
            // Level 2 cache lookup
            //
            var args = new object[] { arg0, arg1, arg2, arg3, arg4, arg5, arg6 };

            //
            // Any applicable rules in level 2 cache?
            //
            if ((applicable = CallSiteOps.FindApplicableRules(@this, args)) != null) {
                for (index = 0, count = applicable.Length; index < count; index++) {
                    rule = applicable[index];

                    //
                    // Execute the rule
                    //
                    ruleTarget = CallSiteOps.SetTarget(@this, rule);

                    try {
                        result = ruleTarget(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6);
                        if (match) {
                            return result;
                        }
                    } finally {
                        if (match) {
                            //
                            // Rule worked. Add it to level 1 cache
                            //
                            CallSiteOps.AddRule(@this, rule);
                        }
                    }

                    if (startingTarget == ruleTarget) {
                        // If we've gone megamorphic we can still template off the L2 cache
                        originalRule = rule;
                    }

                    // Rule didn't match, try the next one
                    match = true;
                }
            }


            //
            // Miss on Level 0, 1 and 2 caches. Create new rule
            //

            rule = null;

            for (; ; ) {
                rule = CallSiteOps.CreateNewRule(@this, rule, originalRule, args);

                //
                // Execute the rule on the matchmaker site
                //

                ruleTarget = CallSiteOps.SetTarget(@this, rule);

                try {
                    result = ruleTarget(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6);
                    if (match) {
                        return result;
                    }
                } finally {
                    if (match) {
                        //
                        // The rule worked. Add it to level 1 cache.
                        //
                        CallSiteOps.AddRule(@this, rule);
                    }
                }

                // Rule we got back didn't work, try another one
                match = true;
            }
        }


        [Obsolete("pregenerated CallSite<T>.Update delegate", true)]
        internal static TRet UpdateAndExecute8<T0, T1, T2, T3, T4, T5, T6, T7, TRet>(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7) {
            //
            // Declare the locals here upfront. It actually saves JIT stack space.
            //
            var @this = (CallSite<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, TRet>>)site;
            CallSiteRule<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, TRet>>[] applicable;
            CallSiteRule<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, TRet>> rule;
            Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, TRet> ruleTarget, startingTarget = @this.Target;
            TRet result;

            int count, index;
            CallSiteRule<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, TRet>> originalRule = null;

            //
            // Create matchmaker and its site. We'll need them regardless.
            //
            bool match = true;
            site = CallSiteOps.CreateMatchmaker(
                @this,
                (mm_site, mm_arg0, mm_arg1, mm_arg2, mm_arg3, mm_arg4, mm_arg5, mm_arg6, mm_arg7) => {
                    match = false;
                    return default(TRet);
                }
            );

            //
            // Level 1 cache lookup
            //
            if ((applicable = CallSiteOps.GetRules(@this)) != null) {
                for (index = 0, count = applicable.Length; index < count; index++) {
                    rule = applicable[index];

                    //
                    // Execute the rule
                    //
                    ruleTarget = CallSiteOps.SetTarget(@this, rule);

                    try {
                        result = ruleTarget(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
                        if (match) {
                            return result;
                        }
                    } finally {
                        if (match) {
                            //
                            // Match in Level 1 cache. We saw the arguments that match the rule before and now we
                            // see them again. The site is polymorphic. Update the delegate and keep running
                            //
                            CallSiteOps.SetPolymorphicTarget(@this);
                        }
                    }

                    if (startingTarget == ruleTarget) {
                        // our rule was previously monomorphic, if we produce another monomorphic
                        // rule we should try and share code between the two.
                        originalRule = rule;
                    }

                    // Rule didn't match, try the next one
                    match = true;            
                }
            }

            //
            // Level 2 cache lookup
            //
            var args = new object[] { arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7 };

            //
            // Any applicable rules in level 2 cache?
            //
            if ((applicable = CallSiteOps.FindApplicableRules(@this, args)) != null) {
                for (index = 0, count = applicable.Length; index < count; index++) {
                    rule = applicable[index];

                    //
                    // Execute the rule
                    //
                    ruleTarget = CallSiteOps.SetTarget(@this, rule);

                    try {
                        result = ruleTarget(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
                        if (match) {
                            return result;
                        }
                    } finally {
                        if (match) {
                            //
                            // Rule worked. Add it to level 1 cache
                            //
                            CallSiteOps.AddRule(@this, rule);
                        }
                    }

                    if (startingTarget == ruleTarget) {
                        // If we've gone megamorphic we can still template off the L2 cache
                        originalRule = rule;
                    }

                    // Rule didn't match, try the next one
                    match = true;
                }
            }


            //
            // Miss on Level 0, 1 and 2 caches. Create new rule
            //

            rule = null;

            for (; ; ) {
                rule = CallSiteOps.CreateNewRule(@this, rule, originalRule, args);

                //
                // Execute the rule on the matchmaker site
                //

                ruleTarget = CallSiteOps.SetTarget(@this, rule);

                try {
                    result = ruleTarget(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
                    if (match) {
                        return result;
                    }
                } finally {
                    if (match) {
                        //
                        // The rule worked. Add it to level 1 cache.
                        //
                        CallSiteOps.AddRule(@this, rule);
                    }
                }

                // Rule we got back didn't work, try another one
                match = true;
            }
        }


        [Obsolete("pregenerated CallSite<T>.Update delegate", true)]
        internal static TRet UpdateAndExecute9<T0, T1, T2, T3, T4, T5, T6, T7, T8, TRet>(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8) {
            //
            // Declare the locals here upfront. It actually saves JIT stack space.
            //
            var @this = (CallSite<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, TRet>>)site;
            CallSiteRule<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, TRet>>[] applicable;
            CallSiteRule<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, TRet>> rule;
            Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, TRet> ruleTarget, startingTarget = @this.Target;
            TRet result;

            int count, index;
            CallSiteRule<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, TRet>> originalRule = null;

            //
            // Create matchmaker and its site. We'll need them regardless.
            //
            bool match = true;
            site = CallSiteOps.CreateMatchmaker(
                @this,
                (mm_site, mm_arg0, mm_arg1, mm_arg2, mm_arg3, mm_arg4, mm_arg5, mm_arg6, mm_arg7, mm_arg8) => {
                    match = false;
                    return default(TRet);
                }
            );

            //
            // Level 1 cache lookup
            //
            if ((applicable = CallSiteOps.GetRules(@this)) != null) {
                for (index = 0, count = applicable.Length; index < count; index++) {
                    rule = applicable[index];

                    //
                    // Execute the rule
                    //
                    ruleTarget = CallSiteOps.SetTarget(@this, rule);

                    try {
                        result = ruleTarget(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
                        if (match) {
                            return result;
                        }
                    } finally {
                        if (match) {
                            //
                            // Match in Level 1 cache. We saw the arguments that match the rule before and now we
                            // see them again. The site is polymorphic. Update the delegate and keep running
                            //
                            CallSiteOps.SetPolymorphicTarget(@this);
                        }
                    }

                    if (startingTarget == ruleTarget) {
                        // our rule was previously monomorphic, if we produce another monomorphic
                        // rule we should try and share code between the two.
                        originalRule = rule;
                    }

                    // Rule didn't match, try the next one
                    match = true;            
                }
            }

            //
            // Level 2 cache lookup
            //
            var args = new object[] { arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8 };

            //
            // Any applicable rules in level 2 cache?
            //
            if ((applicable = CallSiteOps.FindApplicableRules(@this, args)) != null) {
                for (index = 0, count = applicable.Length; index < count; index++) {
                    rule = applicable[index];

                    //
                    // Execute the rule
                    //
                    ruleTarget = CallSiteOps.SetTarget(@this, rule);

                    try {
                        result = ruleTarget(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
                        if (match) {
                            return result;
                        }
                    } finally {
                        if (match) {
                            //
                            // Rule worked. Add it to level 1 cache
                            //
                            CallSiteOps.AddRule(@this, rule);
                        }
                    }

                    if (startingTarget == ruleTarget) {
                        // If we've gone megamorphic we can still template off the L2 cache
                        originalRule = rule;
                    }

                    // Rule didn't match, try the next one
                    match = true;
                }
            }


            //
            // Miss on Level 0, 1 and 2 caches. Create new rule
            //

            rule = null;

            for (; ; ) {
                rule = CallSiteOps.CreateNewRule(@this, rule, originalRule, args);

                //
                // Execute the rule on the matchmaker site
                //

                ruleTarget = CallSiteOps.SetTarget(@this, rule);

                try {
                    result = ruleTarget(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
                    if (match) {
                        return result;
                    }
                } finally {
                    if (match) {
                        //
                        // The rule worked. Add it to level 1 cache.
                        //
                        CallSiteOps.AddRule(@this, rule);
                    }
                }

                // Rule we got back didn't work, try another one
                match = true;
            }
        }


        [Obsolete("pregenerated CallSite<T>.Update delegate", true)]
        internal static TRet UpdateAndExecute10<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, TRet>(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9) {
            //
            // Declare the locals here upfront. It actually saves JIT stack space.
            //
            var @this = (CallSite<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, TRet>>)site;
            CallSiteRule<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, TRet>>[] applicable;
            CallSiteRule<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, TRet>> rule;
            Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, TRet> ruleTarget, startingTarget = @this.Target;
            TRet result;

            int count, index;
            CallSiteRule<Func<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, TRet>> originalRule = null;

            //
            // Create matchmaker and its site. We'll need them regardless.
            //
            bool match = true;
            site = CallSiteOps.CreateMatchmaker(
                @this,
                (mm_site, mm_arg0, mm_arg1, mm_arg2, mm_arg3, mm_arg4, mm_arg5, mm_arg6, mm_arg7, mm_arg8, mm_arg9) => {
                    match = false;
                    return default(TRet);
                }
            );

            //
            // Level 1 cache lookup
            //
            if ((applicable = CallSiteOps.GetRules(@this)) != null) {
                for (index = 0, count = applicable.Length; index < count; index++) {
                    rule = applicable[index];

                    //
                    // Execute the rule
                    //
                    ruleTarget = CallSiteOps.SetTarget(@this, rule);

                    try {
                        result = ruleTarget(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
                        if (match) {
                            return result;
                        }
                    } finally {
                        if (match) {
                            //
                            // Match in Level 1 cache. We saw the arguments that match the rule before and now we
                            // see them again. The site is polymorphic. Update the delegate and keep running
                            //
                            CallSiteOps.SetPolymorphicTarget(@this);
                        }
                    }

                    if (startingTarget == ruleTarget) {
                        // our rule was previously monomorphic, if we produce another monomorphic
                        // rule we should try and share code between the two.
                        originalRule = rule;
                    }

                    // Rule didn't match, try the next one
                    match = true;            
                }
            }

            //
            // Level 2 cache lookup
            //
            var args = new object[] { arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9 };

            //
            // Any applicable rules in level 2 cache?
            //
            if ((applicable = CallSiteOps.FindApplicableRules(@this, args)) != null) {
                for (index = 0, count = applicable.Length; index < count; index++) {
                    rule = applicable[index];

                    //
                    // Execute the rule
                    //
                    ruleTarget = CallSiteOps.SetTarget(@this, rule);

                    try {
                        result = ruleTarget(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
                        if (match) {
                            return result;
                        }
                    } finally {
                        if (match) {
                            //
                            // Rule worked. Add it to level 1 cache
                            //
                            CallSiteOps.AddRule(@this, rule);
                        }
                    }

                    if (startingTarget == ruleTarget) {
                        // If we've gone megamorphic we can still template off the L2 cache
                        originalRule = rule;
                    }

                    // Rule didn't match, try the next one
                    match = true;
                }
            }


            //
            // Miss on Level 0, 1 and 2 caches. Create new rule
            //

            rule = null;

            for (; ; ) {
                rule = CallSiteOps.CreateNewRule(@this, rule, originalRule, args);

                //
                // Execute the rule on the matchmaker site
                //

                ruleTarget = CallSiteOps.SetTarget(@this, rule);

                try {
                    result = ruleTarget(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
                    if (match) {
                        return result;
                    }
                } finally {
                    if (match) {
                        //
                        // The rule worked. Add it to level 1 cache.
                        //
                        CallSiteOps.AddRule(@this, rule);
                    }
                }

                // Rule we got back didn't work, try another one
                match = true;
            }
        }


        [Obsolete("pregenerated CallSite<T>.Update delegate", true)]
        internal static void UpdateAndExecuteVoid1<T0>(CallSite site, T0 arg0) {
            //
            // Declare the locals here upfront. It actually saves JIT stack space.
            //
            var @this = (CallSite<Action<CallSite, T0>>)site;
            CallSiteRule<Action<CallSite, T0>>[] applicable;
            CallSiteRule<Action<CallSite, T0>> rule;
            Action<CallSite, T0> ruleTarget, startingTarget = @this.Target;

            int count, index;
            CallSiteRule<Action<CallSite, T0>> originalRule = null;

            //
            // Create matchmaker and its site. We'll need them regardless.
            //
            bool match = true;
            site = CallSiteOps.CreateMatchmaker(
                @this,
                (mm_site, mm_arg0) => {
                    match = false;
                    return;
                }
            );

            //
            // Level 1 cache lookup
            //
            if ((applicable = CallSiteOps.GetRules(@this)) != null) {
                for (index = 0, count = applicable.Length; index < count; index++) {
                    rule = applicable[index];

                    //
                    // Execute the rule
                    //
                    ruleTarget = CallSiteOps.SetTarget(@this, rule);

                    try {
                         ruleTarget(site, arg0);
                        if (match) {
                            return;
                        }
                    } finally {
                        if (match) {
                            //
                            // Match in Level 1 cache. We saw the arguments that match the rule before and now we
                            // see them again. The site is polymorphic. Update the delegate and keep running
                            //
                            CallSiteOps.SetPolymorphicTarget(@this);
                        }
                    }

                    if (startingTarget == ruleTarget) {
                        // our rule was previously monomorphic, if we produce another monomorphic
                        // rule we should try and share code between the two.
                        originalRule = rule;
                    }

                    // Rule didn't match, try the next one
                    match = true;            
                }
            }

            //
            // Level 2 cache lookup
            //
            var args = new object[] { arg0 };

            //
            // Any applicable rules in level 2 cache?
            //
            if ((applicable = CallSiteOps.FindApplicableRules(@this, args)) != null) {
                for (index = 0, count = applicable.Length; index < count; index++) {
                    rule = applicable[index];

                    //
                    // Execute the rule
                    //
                    ruleTarget = CallSiteOps.SetTarget(@this, rule);

                    try {
                         ruleTarget(site, arg0);
                        if (match) {
                            return;
                        }
                    } finally {
                        if (match) {
                            //
                            // Rule worked. Add it to level 1 cache
                            //
                            CallSiteOps.AddRule(@this, rule);
                        }
                    }

                    if (startingTarget == ruleTarget) {
                        // If we've gone megamorphic we can still template off the L2 cache
                        originalRule = rule;
                    }

                    // Rule didn't match, try the next one
                    match = true;
                }
            }


            //
            // Miss on Level 0, 1 and 2 caches. Create new rule
            //

            rule = null;

            for (; ; ) {
                rule = CallSiteOps.CreateNewRule(@this, rule, originalRule, args);

                //
                // Execute the rule on the matchmaker site
                //

                ruleTarget = CallSiteOps.SetTarget(@this, rule);

                try {
                     ruleTarget(site, arg0);
                    if (match) {
                        return;
                    }
                } finally {
                    if (match) {
                        //
                        // The rule worked. Add it to level 1 cache.
                        //
                        CallSiteOps.AddRule(@this, rule);
                    }
                }

                // Rule we got back didn't work, try another one
                match = true;
            }
        }


        [Obsolete("pregenerated CallSite<T>.Update delegate", true)]
        internal static void UpdateAndExecuteVoid2<T0, T1>(CallSite site, T0 arg0, T1 arg1) {
            //
            // Declare the locals here upfront. It actually saves JIT stack space.
            //
            var @this = (CallSite<Action<CallSite, T0, T1>>)site;
            CallSiteRule<Action<CallSite, T0, T1>>[] applicable;
            CallSiteRule<Action<CallSite, T0, T1>> rule;
            Action<CallSite, T0, T1> ruleTarget, startingTarget = @this.Target;

            int count, index;
            CallSiteRule<Action<CallSite, T0, T1>> originalRule = null;

            //
            // Create matchmaker and its site. We'll need them regardless.
            //
            bool match = true;
            site = CallSiteOps.CreateMatchmaker(
                @this,
                (mm_site, mm_arg0, mm_arg1) => {
                    match = false;
                    return;
                }
            );

            //
            // Level 1 cache lookup
            //
            if ((applicable = CallSiteOps.GetRules(@this)) != null) {
                for (index = 0, count = applicable.Length; index < count; index++) {
                    rule = applicable[index];

                    //
                    // Execute the rule
                    //
                    ruleTarget = CallSiteOps.SetTarget(@this, rule);

                    try {
                         ruleTarget(site, arg0, arg1);
                        if (match) {
                            return;
                        }
                    } finally {
                        if (match) {
                            //
                            // Match in Level 1 cache. We saw the arguments that match the rule before and now we
                            // see them again. The site is polymorphic. Update the delegate and keep running
                            //
                            CallSiteOps.SetPolymorphicTarget(@this);
                        }
                    }

                    if (startingTarget == ruleTarget) {
                        // our rule was previously monomorphic, if we produce another monomorphic
                        // rule we should try and share code between the two.
                        originalRule = rule;
                    }

                    // Rule didn't match, try the next one
                    match = true;            
                }
            }

            //
            // Level 2 cache lookup
            //
            var args = new object[] { arg0, arg1 };

            //
            // Any applicable rules in level 2 cache?
            //
            if ((applicable = CallSiteOps.FindApplicableRules(@this, args)) != null) {
                for (index = 0, count = applicable.Length; index < count; index++) {
                    rule = applicable[index];

                    //
                    // Execute the rule
                    //
                    ruleTarget = CallSiteOps.SetTarget(@this, rule);

                    try {
                         ruleTarget(site, arg0, arg1);
                        if (match) {
                            return;
                        }
                    } finally {
                        if (match) {
                            //
                            // Rule worked. Add it to level 1 cache
                            //
                            CallSiteOps.AddRule(@this, rule);
                        }
                    }

                    if (startingTarget == ruleTarget) {
                        // If we've gone megamorphic we can still template off the L2 cache
                        originalRule = rule;
                    }

                    // Rule didn't match, try the next one
                    match = true;
                }
            }


            //
            // Miss on Level 0, 1 and 2 caches. Create new rule
            //

            rule = null;

            for (; ; ) {
                rule = CallSiteOps.CreateNewRule(@this, rule, originalRule, args);

                //
                // Execute the rule on the matchmaker site
                //

                ruleTarget = CallSiteOps.SetTarget(@this, rule);

                try {
                     ruleTarget(site, arg0, arg1);
                    if (match) {
                        return;
                    }
                } finally {
                    if (match) {
                        //
                        // The rule worked. Add it to level 1 cache.
                        //
                        CallSiteOps.AddRule(@this, rule);
                    }
                }

                // Rule we got back didn't work, try another one
                match = true;
            }
        }


        [Obsolete("pregenerated CallSite<T>.Update delegate", true)]
        internal static void UpdateAndExecuteVoid3<T0, T1, T2>(CallSite site, T0 arg0, T1 arg1, T2 arg2) {
            //
            // Declare the locals here upfront. It actually saves JIT stack space.
            //
            var @this = (CallSite<Action<CallSite, T0, T1, T2>>)site;
            CallSiteRule<Action<CallSite, T0, T1, T2>>[] applicable;
            CallSiteRule<Action<CallSite, T0, T1, T2>> rule;
            Action<CallSite, T0, T1, T2> ruleTarget, startingTarget = @this.Target;

            int count, index;
            CallSiteRule<Action<CallSite, T0, T1, T2>> originalRule = null;

            //
            // Create matchmaker and its site. We'll need them regardless.
            //
            bool match = true;
            site = CallSiteOps.CreateMatchmaker(
                @this,
                (mm_site, mm_arg0, mm_arg1, mm_arg2) => {
                    match = false;
                    return;
                }
            );

            //
            // Level 1 cache lookup
            //
            if ((applicable = CallSiteOps.GetRules(@this)) != null) {
                for (index = 0, count = applicable.Length; index < count; index++) {
                    rule = applicable[index];

                    //
                    // Execute the rule
                    //
                    ruleTarget = CallSiteOps.SetTarget(@this, rule);

                    try {
                         ruleTarget(site, arg0, arg1, arg2);
                        if (match) {
                            return;
                        }
                    } finally {
                        if (match) {
                            //
                            // Match in Level 1 cache. We saw the arguments that match the rule before and now we
                            // see them again. The site is polymorphic. Update the delegate and keep running
                            //
                            CallSiteOps.SetPolymorphicTarget(@this);
                        }
                    }

                    if (startingTarget == ruleTarget) {
                        // our rule was previously monomorphic, if we produce another monomorphic
                        // rule we should try and share code between the two.
                        originalRule = rule;
                    }

                    // Rule didn't match, try the next one
                    match = true;            
                }
            }

            //
            // Level 2 cache lookup
            //
            var args = new object[] { arg0, arg1, arg2 };

            //
            // Any applicable rules in level 2 cache?
            //
            if ((applicable = CallSiteOps.FindApplicableRules(@this, args)) != null) {
                for (index = 0, count = applicable.Length; index < count; index++) {
                    rule = applicable[index];

                    //
                    // Execute the rule
                    //
                    ruleTarget = CallSiteOps.SetTarget(@this, rule);

                    try {
                         ruleTarget(site, arg0, arg1, arg2);
                        if (match) {
                            return;
                        }
                    } finally {
                        if (match) {
                            //
                            // Rule worked. Add it to level 1 cache
                            //
                            CallSiteOps.AddRule(@this, rule);
                        }
                    }

                    if (startingTarget == ruleTarget) {
                        // If we've gone megamorphic we can still template off the L2 cache
                        originalRule = rule;
                    }

                    // Rule didn't match, try the next one
                    match = true;
                }
            }


            //
            // Miss on Level 0, 1 and 2 caches. Create new rule
            //

            rule = null;

            for (; ; ) {
                rule = CallSiteOps.CreateNewRule(@this, rule, originalRule, args);

                //
                // Execute the rule on the matchmaker site
                //

                ruleTarget = CallSiteOps.SetTarget(@this, rule);

                try {
                     ruleTarget(site, arg0, arg1, arg2);
                    if (match) {
                        return;
                    }
                } finally {
                    if (match) {
                        //
                        // The rule worked. Add it to level 1 cache.
                        //
                        CallSiteOps.AddRule(@this, rule);
                    }
                }

                // Rule we got back didn't work, try another one
                match = true;
            }
        }


        [Obsolete("pregenerated CallSite<T>.Update delegate", true)]
        internal static void UpdateAndExecuteVoid4<T0, T1, T2, T3>(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3) {
            //
            // Declare the locals here upfront. It actually saves JIT stack space.
            //
            var @this = (CallSite<Action<CallSite, T0, T1, T2, T3>>)site;
            CallSiteRule<Action<CallSite, T0, T1, T2, T3>>[] applicable;
            CallSiteRule<Action<CallSite, T0, T1, T2, T3>> rule;
            Action<CallSite, T0, T1, T2, T3> ruleTarget, startingTarget = @this.Target;

            int count, index;
            CallSiteRule<Action<CallSite, T0, T1, T2, T3>> originalRule = null;

            //
            // Create matchmaker and its site. We'll need them regardless.
            //
            bool match = true;
            site = CallSiteOps.CreateMatchmaker(
                @this,
                (mm_site, mm_arg0, mm_arg1, mm_arg2, mm_arg3) => {
                    match = false;
                    return;
                }
            );

            //
            // Level 1 cache lookup
            //
            if ((applicable = CallSiteOps.GetRules(@this)) != null) {
                for (index = 0, count = applicable.Length; index < count; index++) {
                    rule = applicable[index];

                    //
                    // Execute the rule
                    //
                    ruleTarget = CallSiteOps.SetTarget(@this, rule);

                    try {
                         ruleTarget(site, arg0, arg1, arg2, arg3);
                        if (match) {
                            return;
                        }
                    } finally {
                        if (match) {
                            //
                            // Match in Level 1 cache. We saw the arguments that match the rule before and now we
                            // see them again. The site is polymorphic. Update the delegate and keep running
                            //
                            CallSiteOps.SetPolymorphicTarget(@this);
                        }
                    }

                    if (startingTarget == ruleTarget) {
                        // our rule was previously monomorphic, if we produce another monomorphic
                        // rule we should try and share code between the two.
                        originalRule = rule;
                    }

                    // Rule didn't match, try the next one
                    match = true;            
                }
            }

            //
            // Level 2 cache lookup
            //
            var args = new object[] { arg0, arg1, arg2, arg3 };

            //
            // Any applicable rules in level 2 cache?
            //
            if ((applicable = CallSiteOps.FindApplicableRules(@this, args)) != null) {
                for (index = 0, count = applicable.Length; index < count; index++) {
                    rule = applicable[index];

                    //
                    // Execute the rule
                    //
                    ruleTarget = CallSiteOps.SetTarget(@this, rule);

                    try {
                         ruleTarget(site, arg0, arg1, arg2, arg3);
                        if (match) {
                            return;
                        }
                    } finally {
                        if (match) {
                            //
                            // Rule worked. Add it to level 1 cache
                            //
                            CallSiteOps.AddRule(@this, rule);
                        }
                    }

                    if (startingTarget == ruleTarget) {
                        // If we've gone megamorphic we can still template off the L2 cache
                        originalRule = rule;
                    }

                    // Rule didn't match, try the next one
                    match = true;
                }
            }


            //
            // Miss on Level 0, 1 and 2 caches. Create new rule
            //

            rule = null;

            for (; ; ) {
                rule = CallSiteOps.CreateNewRule(@this, rule, originalRule, args);

                //
                // Execute the rule on the matchmaker site
                //

                ruleTarget = CallSiteOps.SetTarget(@this, rule);

                try {
                     ruleTarget(site, arg0, arg1, arg2, arg3);
                    if (match) {
                        return;
                    }
                } finally {
                    if (match) {
                        //
                        // The rule worked. Add it to level 1 cache.
                        //
                        CallSiteOps.AddRule(@this, rule);
                    }
                }

                // Rule we got back didn't work, try another one
                match = true;
            }
        }


        [Obsolete("pregenerated CallSite<T>.Update delegate", true)]
        internal static void UpdateAndExecuteVoid5<T0, T1, T2, T3, T4>(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4) {
            //
            // Declare the locals here upfront. It actually saves JIT stack space.
            //
            var @this = (CallSite<Action<CallSite, T0, T1, T2, T3, T4>>)site;
            CallSiteRule<Action<CallSite, T0, T1, T2, T3, T4>>[] applicable;
            CallSiteRule<Action<CallSite, T0, T1, T2, T3, T4>> rule;
            Action<CallSite, T0, T1, T2, T3, T4> ruleTarget, startingTarget = @this.Target;

            int count, index;
            CallSiteRule<Action<CallSite, T0, T1, T2, T3, T4>> originalRule = null;

            //
            // Create matchmaker and its site. We'll need them regardless.
            //
            bool match = true;
            site = CallSiteOps.CreateMatchmaker(
                @this,
                (mm_site, mm_arg0, mm_arg1, mm_arg2, mm_arg3, mm_arg4) => {
                    match = false;
                    return;
                }
            );

            //
            // Level 1 cache lookup
            //
            if ((applicable = CallSiteOps.GetRules(@this)) != null) {
                for (index = 0, count = applicable.Length; index < count; index++) {
                    rule = applicable[index];

                    //
                    // Execute the rule
                    //
                    ruleTarget = CallSiteOps.SetTarget(@this, rule);

                    try {
                         ruleTarget(site, arg0, arg1, arg2, arg3, arg4);
                        if (match) {
                            return;
                        }
                    } finally {
                        if (match) {
                            //
                            // Match in Level 1 cache. We saw the arguments that match the rule before and now we
                            // see them again. The site is polymorphic. Update the delegate and keep running
                            //
                            CallSiteOps.SetPolymorphicTarget(@this);
                        }
                    }

                    if (startingTarget == ruleTarget) {
                        // our rule was previously monomorphic, if we produce another monomorphic
                        // rule we should try and share code between the two.
                        originalRule = rule;
                    }

                    // Rule didn't match, try the next one
                    match = true;            
                }
            }

            //
            // Level 2 cache lookup
            //
            var args = new object[] { arg0, arg1, arg2, arg3, arg4 };

            //
            // Any applicable rules in level 2 cache?
            //
            if ((applicable = CallSiteOps.FindApplicableRules(@this, args)) != null) {
                for (index = 0, count = applicable.Length; index < count; index++) {
                    rule = applicable[index];

                    //
                    // Execute the rule
                    //
                    ruleTarget = CallSiteOps.SetTarget(@this, rule);

                    try {
                         ruleTarget(site, arg0, arg1, arg2, arg3, arg4);
                        if (match) {
                            return;
                        }
                    } finally {
                        if (match) {
                            //
                            // Rule worked. Add it to level 1 cache
                            //
                            CallSiteOps.AddRule(@this, rule);
                        }
                    }

                    if (startingTarget == ruleTarget) {
                        // If we've gone megamorphic we can still template off the L2 cache
                        originalRule = rule;
                    }

                    // Rule didn't match, try the next one
                    match = true;
                }
            }


            //
            // Miss on Level 0, 1 and 2 caches. Create new rule
            //

            rule = null;

            for (; ; ) {
                rule = CallSiteOps.CreateNewRule(@this, rule, originalRule, args);

                //
                // Execute the rule on the matchmaker site
                //

                ruleTarget = CallSiteOps.SetTarget(@this, rule);

                try {
                     ruleTarget(site, arg0, arg1, arg2, arg3, arg4);
                    if (match) {
                        return;
                    }
                } finally {
                    if (match) {
                        //
                        // The rule worked. Add it to level 1 cache.
                        //
                        CallSiteOps.AddRule(@this, rule);
                    }
                }

                // Rule we got back didn't work, try another one
                match = true;
            }
        }


        [Obsolete("pregenerated CallSite<T>.Update delegate", true)]
        internal static void UpdateAndExecuteVoid6<T0, T1, T2, T3, T4, T5>(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5) {
            //
            // Declare the locals here upfront. It actually saves JIT stack space.
            //
            var @this = (CallSite<Action<CallSite, T0, T1, T2, T3, T4, T5>>)site;
            CallSiteRule<Action<CallSite, T0, T1, T2, T3, T4, T5>>[] applicable;
            CallSiteRule<Action<CallSite, T0, T1, T2, T3, T4, T5>> rule;
            Action<CallSite, T0, T1, T2, T3, T4, T5> ruleTarget, startingTarget = @this.Target;

            int count, index;
            CallSiteRule<Action<CallSite, T0, T1, T2, T3, T4, T5>> originalRule = null;

            //
            // Create matchmaker and its site. We'll need them regardless.
            //
            bool match = true;
            site = CallSiteOps.CreateMatchmaker(
                @this,
                (mm_site, mm_arg0, mm_arg1, mm_arg2, mm_arg3, mm_arg4, mm_arg5) => {
                    match = false;
                    return;
                }
            );

            //
            // Level 1 cache lookup
            //
            if ((applicable = CallSiteOps.GetRules(@this)) != null) {
                for (index = 0, count = applicable.Length; index < count; index++) {
                    rule = applicable[index];

                    //
                    // Execute the rule
                    //
                    ruleTarget = CallSiteOps.SetTarget(@this, rule);

                    try {
                         ruleTarget(site, arg0, arg1, arg2, arg3, arg4, arg5);
                        if (match) {
                            return;
                        }
                    } finally {
                        if (match) {
                            //
                            // Match in Level 1 cache. We saw the arguments that match the rule before and now we
                            // see them again. The site is polymorphic. Update the delegate and keep running
                            //
                            CallSiteOps.SetPolymorphicTarget(@this);
                        }
                    }

                    if (startingTarget == ruleTarget) {
                        // our rule was previously monomorphic, if we produce another monomorphic
                        // rule we should try and share code between the two.
                        originalRule = rule;
                    }

                    // Rule didn't match, try the next one
                    match = true;            
                }
            }

            //
            // Level 2 cache lookup
            //
            var args = new object[] { arg0, arg1, arg2, arg3, arg4, arg5 };

            //
            // Any applicable rules in level 2 cache?
            //
            if ((applicable = CallSiteOps.FindApplicableRules(@this, args)) != null) {
                for (index = 0, count = applicable.Length; index < count; index++) {
                    rule = applicable[index];

                    //
                    // Execute the rule
                    //
                    ruleTarget = CallSiteOps.SetTarget(@this, rule);

                    try {
                         ruleTarget(site, arg0, arg1, arg2, arg3, arg4, arg5);
                        if (match) {
                            return;
                        }
                    } finally {
                        if (match) {
                            //
                            // Rule worked. Add it to level 1 cache
                            //
                            CallSiteOps.AddRule(@this, rule);
                        }
                    }

                    if (startingTarget == ruleTarget) {
                        // If we've gone megamorphic we can still template off the L2 cache
                        originalRule = rule;
                    }

                    // Rule didn't match, try the next one
                    match = true;
                }
            }


            //
            // Miss on Level 0, 1 and 2 caches. Create new rule
            //

            rule = null;

            for (; ; ) {
                rule = CallSiteOps.CreateNewRule(@this, rule, originalRule, args);

                //
                // Execute the rule on the matchmaker site
                //

                ruleTarget = CallSiteOps.SetTarget(@this, rule);

                try {
                     ruleTarget(site, arg0, arg1, arg2, arg3, arg4, arg5);
                    if (match) {
                        return;
                    }
                } finally {
                    if (match) {
                        //
                        // The rule worked. Add it to level 1 cache.
                        //
                        CallSiteOps.AddRule(@this, rule);
                    }
                }

                // Rule we got back didn't work, try another one
                match = true;
            }
        }


        [Obsolete("pregenerated CallSite<T>.Update delegate", true)]
        internal static void UpdateAndExecuteVoid7<T0, T1, T2, T3, T4, T5, T6>(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6) {
            //
            // Declare the locals here upfront. It actually saves JIT stack space.
            //
            var @this = (CallSite<Action<CallSite, T0, T1, T2, T3, T4, T5, T6>>)site;
            CallSiteRule<Action<CallSite, T0, T1, T2, T3, T4, T5, T6>>[] applicable;
            CallSiteRule<Action<CallSite, T0, T1, T2, T3, T4, T5, T6>> rule;
            Action<CallSite, T0, T1, T2, T3, T4, T5, T6> ruleTarget, startingTarget = @this.Target;

            int count, index;
            CallSiteRule<Action<CallSite, T0, T1, T2, T3, T4, T5, T6>> originalRule = null;

            //
            // Create matchmaker and its site. We'll need them regardless.
            //
            bool match = true;
            site = CallSiteOps.CreateMatchmaker(
                @this,
                (mm_site, mm_arg0, mm_arg1, mm_arg2, mm_arg3, mm_arg4, mm_arg5, mm_arg6) => {
                    match = false;
                    return;
                }
            );

            //
            // Level 1 cache lookup
            //
            if ((applicable = CallSiteOps.GetRules(@this)) != null) {
                for (index = 0, count = applicable.Length; index < count; index++) {
                    rule = applicable[index];

                    //
                    // Execute the rule
                    //
                    ruleTarget = CallSiteOps.SetTarget(@this, rule);

                    try {
                         ruleTarget(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6);
                        if (match) {
                            return;
                        }
                    } finally {
                        if (match) {
                            //
                            // Match in Level 1 cache. We saw the arguments that match the rule before and now we
                            // see them again. The site is polymorphic. Update the delegate and keep running
                            //
                            CallSiteOps.SetPolymorphicTarget(@this);
                        }
                    }

                    if (startingTarget == ruleTarget) {
                        // our rule was previously monomorphic, if we produce another monomorphic
                        // rule we should try and share code between the two.
                        originalRule = rule;
                    }

                    // Rule didn't match, try the next one
                    match = true;            
                }
            }

            //
            // Level 2 cache lookup
            //
            var args = new object[] { arg0, arg1, arg2, arg3, arg4, arg5, arg6 };

            //
            // Any applicable rules in level 2 cache?
            //
            if ((applicable = CallSiteOps.FindApplicableRules(@this, args)) != null) {
                for (index = 0, count = applicable.Length; index < count; index++) {
                    rule = applicable[index];

                    //
                    // Execute the rule
                    //
                    ruleTarget = CallSiteOps.SetTarget(@this, rule);

                    try {
                         ruleTarget(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6);
                        if (match) {
                            return;
                        }
                    } finally {
                        if (match) {
                            //
                            // Rule worked. Add it to level 1 cache
                            //
                            CallSiteOps.AddRule(@this, rule);
                        }
                    }

                    if (startingTarget == ruleTarget) {
                        // If we've gone megamorphic we can still template off the L2 cache
                        originalRule = rule;
                    }

                    // Rule didn't match, try the next one
                    match = true;
                }
            }


            //
            // Miss on Level 0, 1 and 2 caches. Create new rule
            //

            rule = null;

            for (; ; ) {
                rule = CallSiteOps.CreateNewRule(@this, rule, originalRule, args);

                //
                // Execute the rule on the matchmaker site
                //

                ruleTarget = CallSiteOps.SetTarget(@this, rule);

                try {
                     ruleTarget(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6);
                    if (match) {
                        return;
                    }
                } finally {
                    if (match) {
                        //
                        // The rule worked. Add it to level 1 cache.
                        //
                        CallSiteOps.AddRule(@this, rule);
                    }
                }

                // Rule we got back didn't work, try another one
                match = true;
            }
        }


        [Obsolete("pregenerated CallSite<T>.Update delegate", true)]
        internal static void UpdateAndExecuteVoid8<T0, T1, T2, T3, T4, T5, T6, T7>(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7) {
            //
            // Declare the locals here upfront. It actually saves JIT stack space.
            //
            var @this = (CallSite<Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7>>)site;
            CallSiteRule<Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7>>[] applicable;
            CallSiteRule<Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7>> rule;
            Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7> ruleTarget, startingTarget = @this.Target;

            int count, index;
            CallSiteRule<Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7>> originalRule = null;

            //
            // Create matchmaker and its site. We'll need them regardless.
            //
            bool match = true;
            site = CallSiteOps.CreateMatchmaker(
                @this,
                (mm_site, mm_arg0, mm_arg1, mm_arg2, mm_arg3, mm_arg4, mm_arg5, mm_arg6, mm_arg7) => {
                    match = false;
                    return;
                }
            );

            //
            // Level 1 cache lookup
            //
            if ((applicable = CallSiteOps.GetRules(@this)) != null) {
                for (index = 0, count = applicable.Length; index < count; index++) {
                    rule = applicable[index];

                    //
                    // Execute the rule
                    //
                    ruleTarget = CallSiteOps.SetTarget(@this, rule);

                    try {
                         ruleTarget(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
                        if (match) {
                            return;
                        }
                    } finally {
                        if (match) {
                            //
                            // Match in Level 1 cache. We saw the arguments that match the rule before and now we
                            // see them again. The site is polymorphic. Update the delegate and keep running
                            //
                            CallSiteOps.SetPolymorphicTarget(@this);
                        }
                    }

                    if (startingTarget == ruleTarget) {
                        // our rule was previously monomorphic, if we produce another monomorphic
                        // rule we should try and share code between the two.
                        originalRule = rule;
                    }

                    // Rule didn't match, try the next one
                    match = true;            
                }
            }

            //
            // Level 2 cache lookup
            //
            var args = new object[] { arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7 };

            //
            // Any applicable rules in level 2 cache?
            //
            if ((applicable = CallSiteOps.FindApplicableRules(@this, args)) != null) {
                for (index = 0, count = applicable.Length; index < count; index++) {
                    rule = applicable[index];

                    //
                    // Execute the rule
                    //
                    ruleTarget = CallSiteOps.SetTarget(@this, rule);

                    try {
                         ruleTarget(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
                        if (match) {
                            return;
                        }
                    } finally {
                        if (match) {
                            //
                            // Rule worked. Add it to level 1 cache
                            //
                            CallSiteOps.AddRule(@this, rule);
                        }
                    }

                    if (startingTarget == ruleTarget) {
                        // If we've gone megamorphic we can still template off the L2 cache
                        originalRule = rule;
                    }

                    // Rule didn't match, try the next one
                    match = true;
                }
            }


            //
            // Miss on Level 0, 1 and 2 caches. Create new rule
            //

            rule = null;

            for (; ; ) {
                rule = CallSiteOps.CreateNewRule(@this, rule, originalRule, args);

                //
                // Execute the rule on the matchmaker site
                //

                ruleTarget = CallSiteOps.SetTarget(@this, rule);

                try {
                     ruleTarget(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
                    if (match) {
                        return;
                    }
                } finally {
                    if (match) {
                        //
                        // The rule worked. Add it to level 1 cache.
                        //
                        CallSiteOps.AddRule(@this, rule);
                    }
                }

                // Rule we got back didn't work, try another one
                match = true;
            }
        }


        [Obsolete("pregenerated CallSite<T>.Update delegate", true)]
        internal static void UpdateAndExecuteVoid9<T0, T1, T2, T3, T4, T5, T6, T7, T8>(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8) {
            //
            // Declare the locals here upfront. It actually saves JIT stack space.
            //
            var @this = (CallSite<Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8>>)site;
            CallSiteRule<Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8>>[] applicable;
            CallSiteRule<Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8>> rule;
            Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8> ruleTarget, startingTarget = @this.Target;

            int count, index;
            CallSiteRule<Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8>> originalRule = null;

            //
            // Create matchmaker and its site. We'll need them regardless.
            //
            bool match = true;
            site = CallSiteOps.CreateMatchmaker(
                @this,
                (mm_site, mm_arg0, mm_arg1, mm_arg2, mm_arg3, mm_arg4, mm_arg5, mm_arg6, mm_arg7, mm_arg8) => {
                    match = false;
                    return;
                }
            );

            //
            // Level 1 cache lookup
            //
            if ((applicable = CallSiteOps.GetRules(@this)) != null) {
                for (index = 0, count = applicable.Length; index < count; index++) {
                    rule = applicable[index];

                    //
                    // Execute the rule
                    //
                    ruleTarget = CallSiteOps.SetTarget(@this, rule);

                    try {
                         ruleTarget(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
                        if (match) {
                            return;
                        }
                    } finally {
                        if (match) {
                            //
                            // Match in Level 1 cache. We saw the arguments that match the rule before and now we
                            // see them again. The site is polymorphic. Update the delegate and keep running
                            //
                            CallSiteOps.SetPolymorphicTarget(@this);
                        }
                    }

                    if (startingTarget == ruleTarget) {
                        // our rule was previously monomorphic, if we produce another monomorphic
                        // rule we should try and share code between the two.
                        originalRule = rule;
                    }

                    // Rule didn't match, try the next one
                    match = true;            
                }
            }

            //
            // Level 2 cache lookup
            //
            var args = new object[] { arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8 };

            //
            // Any applicable rules in level 2 cache?
            //
            if ((applicable = CallSiteOps.FindApplicableRules(@this, args)) != null) {
                for (index = 0, count = applicable.Length; index < count; index++) {
                    rule = applicable[index];

                    //
                    // Execute the rule
                    //
                    ruleTarget = CallSiteOps.SetTarget(@this, rule);

                    try {
                         ruleTarget(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
                        if (match) {
                            return;
                        }
                    } finally {
                        if (match) {
                            //
                            // Rule worked. Add it to level 1 cache
                            //
                            CallSiteOps.AddRule(@this, rule);
                        }
                    }

                    if (startingTarget == ruleTarget) {
                        // If we've gone megamorphic we can still template off the L2 cache
                        originalRule = rule;
                    }

                    // Rule didn't match, try the next one
                    match = true;
                }
            }


            //
            // Miss on Level 0, 1 and 2 caches. Create new rule
            //

            rule = null;

            for (; ; ) {
                rule = CallSiteOps.CreateNewRule(@this, rule, originalRule, args);

                //
                // Execute the rule on the matchmaker site
                //

                ruleTarget = CallSiteOps.SetTarget(@this, rule);

                try {
                     ruleTarget(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
                    if (match) {
                        return;
                    }
                } finally {
                    if (match) {
                        //
                        // The rule worked. Add it to level 1 cache.
                        //
                        CallSiteOps.AddRule(@this, rule);
                    }
                }

                // Rule we got back didn't work, try another one
                match = true;
            }
        }


        [Obsolete("pregenerated CallSite<T>.Update delegate", true)]
        internal static void UpdateAndExecuteVoid10<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(CallSite site, T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9) {
            //
            // Declare the locals here upfront. It actually saves JIT stack space.
            //
            var @this = (CallSite<Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>>)site;
            CallSiteRule<Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>>[] applicable;
            CallSiteRule<Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>> rule;
            Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> ruleTarget, startingTarget = @this.Target;

            int count, index;
            CallSiteRule<Action<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>> originalRule = null;

            //
            // Create matchmaker and its site. We'll need them regardless.
            //
            bool match = true;
            site = CallSiteOps.CreateMatchmaker(
                @this,
                (mm_site, mm_arg0, mm_arg1, mm_arg2, mm_arg3, mm_arg4, mm_arg5, mm_arg6, mm_arg7, mm_arg8, mm_arg9) => {
                    match = false;
                    return;
                }
            );

            //
            // Level 1 cache lookup
            //
            if ((applicable = CallSiteOps.GetRules(@this)) != null) {
                for (index = 0, count = applicable.Length; index < count; index++) {
                    rule = applicable[index];

                    //
                    // Execute the rule
                    //
                    ruleTarget = CallSiteOps.SetTarget(@this, rule);

                    try {
                         ruleTarget(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
                        if (match) {
                            return;
                        }
                    } finally {
                        if (match) {
                            //
                            // Match in Level 1 cache. We saw the arguments that match the rule before and now we
                            // see them again. The site is polymorphic. Update the delegate and keep running
                            //
                            CallSiteOps.SetPolymorphicTarget(@this);
                        }
                    }

                    if (startingTarget == ruleTarget) {
                        // our rule was previously monomorphic, if we produce another monomorphic
                        // rule we should try and share code between the two.
                        originalRule = rule;
                    }

                    // Rule didn't match, try the next one
                    match = true;            
                }
            }

            //
            // Level 2 cache lookup
            //
            var args = new object[] { arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9 };

            //
            // Any applicable rules in level 2 cache?
            //
            if ((applicable = CallSiteOps.FindApplicableRules(@this, args)) != null) {
                for (index = 0, count = applicable.Length; index < count; index++) {
                    rule = applicable[index];

                    //
                    // Execute the rule
                    //
                    ruleTarget = CallSiteOps.SetTarget(@this, rule);

                    try {
                         ruleTarget(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
                        if (match) {
                            return;
                        }
                    } finally {
                        if (match) {
                            //
                            // Rule worked. Add it to level 1 cache
                            //
                            CallSiteOps.AddRule(@this, rule);
                        }
                    }

                    if (startingTarget == ruleTarget) {
                        // If we've gone megamorphic we can still template off the L2 cache
                        originalRule = rule;
                    }

                    // Rule didn't match, try the next one
                    match = true;
                }
            }


            //
            // Miss on Level 0, 1 and 2 caches. Create new rule
            //

            rule = null;

            for (; ; ) {
                rule = CallSiteOps.CreateNewRule(@this, rule, originalRule, args);

                //
                // Execute the rule on the matchmaker site
                //

                ruleTarget = CallSiteOps.SetTarget(@this, rule);

                try {
                     ruleTarget(site, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
                    if (match) {
                        return;
                    }
                } finally {
                    if (match) {
                        //
                        // The rule worked. Add it to level 1 cache.
                        //
                        CallSiteOps.AddRule(@this, rule);
                    }
                }

                // Rule we got back didn't work, try another one
                match = true;
            }
        }


        // *** END GENERATED CODE ***

        #endregion
    }
}
