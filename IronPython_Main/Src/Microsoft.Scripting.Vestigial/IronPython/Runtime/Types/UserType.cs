/* ****************************************************************************
 *
 * Copyright (c) Microsoft Corporation. 
 *
 * This source code is subject to terms and conditions of the Microsoft Permissive License. A 
 * copy of the license can be found in the License.html file at the root of this distribution. If 
 * you cannot locate the  Microsoft Permissive License, please send an email to 
 * ironpy@microsoft.com. By using this source code in any fashion, you are agreeing to be bound 
 * by the terms of the Microsoft Permissive License.
 *
 * You must not remove this notice, or any other, from this software.
 *
 *
 * ***************************************************************************/

using System;
using System.Reflection;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using Microsoft.Scripting;
using Microsoft.Scripting.Internal;

using IronPython.Runtime.Calls;
using IronPython.Runtime.Operations;
using IronPython.Compiler.Generation;
using Microsoft.Scripting.Math;

namespace IronPython.Runtime.Types {
    /// <summary>
    /// UserType represents the type of new-style Python classes (which can inherit from built-in types). 
    /// 
    /// Object instances of new-style Python classes are represented by classes generated by NewTypeMaker,
    /// and are named IronPython.NewTypes.someName.
    /// 
    /// OldClass is the equivalent of UserType for old-style Python classes (which cannot inherit from 
    /// built-in types).
    /// </summary>
    public class UserTypeBuilder : ReflectedTypeBuilder {
        private string _name;
        private Tuple _bases;
        private IAttributesCollection _vars;
        private Type _type;
        private bool _hasDict, _hasWeakRef, _hasSlots, _hasFinalizer;

        private UserTypeBuilder(string name, Tuple bases, IAttributesCollection vars) {
            _name = name;
            _bases = bases;
            _vars = vars;
        }

        public static DynamicType Build(CodeContext context, string name, Tuple bases, IAttributesCollection vars) {
            UserTypeBuilder utb = new UserTypeBuilder(name, bases, vars);
            Type type = NewTypeMaker.GetNewType(name, bases, vars);
            DynamicTypeBuilder builder = new DynamicTypeBuilder(name, type);

            utb.Builder = builder;
            utb._type = type;

            return utb.DoBuild(context);
        }

        public static void Build(CodeContext context, DynamicType dt, string name, Tuple bases, IAttributesCollection vars) {
            Type type = NewTypeMaker.GetNewType(name, bases, vars);
            DynamicTypeBuilder builder = DynamicTypeBuilder.GetBuilder(dt);

            UserTypeBuilder utb = new UserTypeBuilder(name, bases, vars);
            utb.Builder = builder;
            utb._type = type;
            builder.SetName(name);

            utb.DoBuild(context);
        }

        class TypePrepender : ICallableWithCodeContext, IFancyCallable {
            BuiltinFunction _ctor;
            DynamicType _type;

            public TypePrepender(DynamicType dt, BuiltinFunction realCtor) {
                _type = dt;
                _ctor = realCtor;
            }

            #region ICallableWithCodeContext Members

            public object Call(CodeContext context, object[] args) {
                object[] realArgs = new object[args.Length + 1];
                realArgs[0] = _type;

                Array.Copy(args, 0, realArgs, 1, args.Length);
                return _ctor.Call(context, realArgs);
            }

            #endregion

            #region IFancyCallable Members

            public object Call(CodeContext context, object[] args, string[] names) {
                object[] realArgs = new object[args.Length + 1];
                realArgs[0] = _type;

                Array.Copy(args, 0, realArgs, 1, args.Length);
                return _ctor.Call(context, realArgs, names);
            }

            #endregion
        }

        private DynamicType DoBuild(CodeContext context) {
            Debug.Assert(Builder != null);

            Builder.SetTypeContext(context.LanguageContext.ContextId);

            Builder.SetConstructor(
                new TypePrepender(Builder.UnfinishedType, BuiltinFunction.MakeMethod(_name, _type.GetConstructors(), FunctionType.Function)));

            Builder.SetDefaultSlotType(delegate(object value) {
                return new DynamicTypeUserDescriptorSlot(value);
            });

            ValidateSupportedInheritance();

            IAttributesCollection fastDict = (IAttributesCollection)_vars;

            Builder.AddSlot(Symbols.Name, new DynamicTypeValueSlot(_name));
            Builder.AddSlot(Symbols.Module, new DynamicTypeValueSlot(fastDict[Symbols.Module]));

            if (fastDict.ContainsKey(Symbols.Slots)) {
                HasSlots = true;
                if (fastDict.ContainsKey(Symbols.Dict)) HasDictionary = true;
                if (fastDict.ContainsKey(Symbols.WeakRef)) HasWeakRef = true;
            } else {
                HasDictionary = true;
                HasWeakRef = true;
            }

            object newInst;
            if (fastDict.TryGetValue(Symbols.NewInst, out newInst) && newInst is PythonFunction) {
                fastDict[Symbols.NewInst] = new StaticMethod(newInst);
            }

            PopulateDefaultDictionary(fastDict);

            bool mixedOldNew = InitializeUserType(context, _bases, fastDict);

            PublishDictionary(fastDict);

            Builder.UnfinishedType.OnChange += new EventHandler<DynamicTypeChangedEventArgs>(DoOperatorPropagation);
            Builder.IsSystemType = false;

            return (DynamicType)Builder.Finish(false);
        }

        private void PublishDictionary(IAttributesCollection dict) {
            foreach (KeyValuePair<SymbolId, object> kvp in dict.SymbolAttributes) {
                DynamicTypeSlot dts = kvp.Value as DynamicTypeSlot;
                if (dts == null) {
                    dts = CreateValueSlot(kvp.Value);
                }

                Builder.AddSlot(kvp.Key, dts);

                AddLookupOperator(Builder.UnfinishedType, kvp.Key);
            }
        }

        /// <summary>
        /// Adds an operator that does a lookup in the type searching according to normal
        /// lookup rules.
        /// </summary>
        internal static bool AddLookupOperator(DynamicType dt, SymbolId id) {
            if (id == Symbols.GetSlice) id = Symbols.GetItem;
            if (id == Symbols.SetSlice) id = Symbols.SetItem;
            if (id == Symbols.DeleteSlice) id = Symbols.DelItem;

            OperatorMapping op;
            if (PythonExtensionTypeAttribute._pythonOperatorTable.TryGetValue(id, out op)) {
                DynamicTypeBuilder builder = DynamicTypeBuilder.GetBuilder(dt);

                // some operators need specific transformations from the DLR semantics into the 
                // Python semantics - those transformations are done here.
                if (op.Operator == Operators.Call) {
                    builder.AddOperator(Operators.Call, MakeDefaultCall(dt));
                } else if (op.Operator == Operators.GetBoundMember) {
                    builder.AddOperator(op.Operator,
                        delegate(CodeContext context, object self, object other, out object ret) {
                            object value;
                            if (!dt.TryGetBoundMember(context, self, id, out value)) {
                                ret = null;
                                return false;
                            }

                            ret = Ops.CallWithContext(context, value, other);
                            return true;
                        }
                    );
                } else if (op.Operator == Operators.SetItem) {
                    AddOperatorSetItem(builder);
                } else if (op.Operator == Operators.GetItem) {
                    AddOperatorGetItem(builder);
                } else if (op.Operator == Operators.DeleteItem) {
                    AddOperatorDeleteItem(builder);
                } else {
                    if (op.IsUnary) {
                        builder.AddOperator(op.Operator,
                            delegate(CodeContext context, object self, out object ret) {
                                object value;
                                if (!dt.TryGetBoundMember(context, self, id, out value)) {
                                    ret = null;
                                    return false;
                                }

                                ret = Ops.CallWithContext(context, value);
                                return true;
                            }
                        );
                    }

                    if (op.IsBinary) {
                        builder.AddOperator(op.Operator,
                            delegate(CodeContext context, object self, object other, out object ret) {
                                object value;
                                if (!dt.TryGetBoundMember(context, self, id, out value)) {
                                    ret = null;
                                    return false;
                                }

                                ret = Ops.CallWithContext(context, value, other);
                                return true;
                            }
                        );
                    }

                    if (op.IsTernary) {
                        builder.AddOperator(op.Operator,
                            delegate(CodeContext context, object self, object value1, object value2, out object ret) {
                                object value;
                                if (!dt.TryGetBoundMember(context, self, id, out value)) {
                                    ret = null;
                                    return false;
                                }

                                ret = Ops.CallWithContext(context,
                                    value,
                                    value1,
                                    value2);
                                return true;
                            }
                        );
                    }
                }
                return true;
            }
            return false;
        }


        internal static void AddOperatorGetItem(DynamicTypeBuilder builder) {
            DynamicType dt = builder.UnfinishedType;

            builder.AddOperator(Operators.GetItem,
                delegate(CodeContext context, object self, object other, out object ret) {
                    Slice slice = other as Slice;
                    if (slice != null && slice.Step == null) {
                        object getSlice;
                        if (dt.TryGetBoundMember(context, self, Symbols.GetSlice, out getSlice)) {
                            int start, stop;
                            slice.DeprecatedFixed(self, out start, out stop);
                            ret = Ops.CallWithContext(context, getSlice, start, stop);
                            return true;
                        }
                    }

                    object value;
                    if (!dt.TryGetBoundMember(context, self, Symbols.GetItem, out value)) {
                        ret = null;
                        return false;
                    }

                    ret = Ops.CallWithContext(context,
                        dt.GetBoundMember(context, self, Symbols.GetItem),
                        other);
                    return true;
                }
            );

        }

        internal static void AddOperatorDeleteItem(DynamicTypeBuilder builder) {
            DynamicType dt = builder.UnfinishedType;

            builder.AddOperator(Operators.DeleteItem,
                delegate(CodeContext context, object self, object other, out object ret) {
                    Slice slice = other as Slice;
                    if (slice != null && slice.Step == null) {
                        object delSlice;
                        if (dt.TryGetBoundMember(context, self, Symbols.DeleteSlice, out delSlice)) {
                            int start, stop;
                            slice.DeprecatedFixed(self, out start, out stop);
                            ret = Ops.CallWithContext(context, delSlice, start, stop);
                            return true;
                        }
                    }

                    object value;
                    if (!dt.TryGetBoundMember(context, self, Symbols.DelItem, out value)) {
                        ret = null;
                        return false;
                    }

                    ret = Ops.CallWithContext(context,
                        value,
                        other);
                    return true;
                }
            );

        }

        internal static void AddOperatorSetItem(DynamicTypeBuilder builder) {
            DynamicType dt = builder.UnfinishedType;

            builder.AddOperator(Operators.SetItem,
                delegate(CodeContext context, object self, object value1, object value2, out object ret) {
                    Slice slice = value1 as Slice;
                    if (slice != null && slice.Step == null) {
                        object setSlice;
                        if (dt.TryGetBoundMember(context, self, Symbols.SetSlice, out setSlice)) {
                            int start, stop;
                            slice.DeprecatedFixed(self, out start, out stop);
                            ret = Ops.CallWithContext(context, setSlice, start, stop, value2);
                            return true;
                        }
                    }

                    object value;
                    if (!dt.TryGetBoundMember(context, self, Symbols.SetItem, out value)) {
                        ret = null;
                        return false;
                    }

                    ret = Ops.CallWithContext(context,
                        value,
                        value1,
                        value2);
                    return true;
                }
            );

        }
        private void DoOperatorPropagation(object sender, DynamicTypeChangedEventArgs args) {
            DynamicType dt = sender as DynamicType;
            Debug.Assert(dt != null);

            if (args.ChangeType == ChangeType.Added) {
                if (args.Symbol == Symbols.GetAttribute) {
                    DynamicTypeBuilder dtb = DynamicTypeBuilder.GetBuilder(dt);

                    CustomAttributeInfo info = new CustomAttributeInfo(args.NewValue);
                    dtb.SetCustomBoundGetter(info.HookedGetAttribute);
                    dtb.AddSlot(Symbols.GetAttribute, new DynamicTypeGetAttributeSlot(dtb.UnfinishedType, info, Symbols.GetAttribute));

                    dtb.ReleaseBuilder();
                    return;
                } else if (args.Symbol == Symbols.SetAttr) {
                    DynamicTypeBuilder dtb = DynamicTypeBuilder.GetBuilder(dt);

                    CustomAttributeInfo info = new CustomAttributeInfo(args.NewValue);
                    dtb.SetCustomSetter(info.HookedSetAttribute);
                    dtb.AddSlot(Symbols.SetAttr, new DynamicTypeGetAttributeSlot(dtb.UnfinishedType, info, Symbols.SetAttr));

                    dtb.ReleaseBuilder();
                    return;
                } else if (args.Symbol == Symbols.DelAttr) {
                    DynamicTypeBuilder dtb = DynamicTypeBuilder.GetBuilder(dt);

                    CustomAttributeInfo info = new CustomAttributeInfo(args.NewValue);
                    dtb.SetCustomDeleter(info.HookedDeleteAttribute);
                    dtb.AddSlot(Symbols.DelAttr, new DynamicTypeGetAttributeSlot(dtb.UnfinishedType, info, Symbols.DelAttr));

                    dtb.ReleaseBuilder();
                    return;
                }
            }

            AddOperatorAndPropagate(args.Context, dt, args.Symbol, args.ChangeType, args.PreviousValue);
        }

        protected void AddOperatorAndPropagate(CodeContext context, DynamicType dt, SymbolId id, ChangeType type, object previous) {
            if ((type == ChangeType.Added && AddLookupOperator(dt, id)) ||
                (type == ChangeType.Removed && RemoveOperator(dt, id))) {
                IList<WeakReference> subtypes = dt.SubTypes;
                if (subtypes == null) return;

                foreach (WeakReference weaksubtype in subtypes) {
                    if (!weaksubtype.IsAlive) continue;

                    DynamicType subtype = (DynamicType)weaksubtype.Target;
                    DynamicTypeSlot dts;

                    if (subtype.TryLookupSlot(context, id, out dts)) {
                        object oldVal;
                        if (dts.TryGetValue(context, null, subtype, out oldVal) && oldVal == previous) {
                            switch (type) {
                                case ChangeType.Added:
                                    AddLookupOperator(subtype, id);
                                    break;
                                case ChangeType.Removed:
                                    RemoveOperator(subtype, id);
                                    break;
                            }
                        }
                    }
                }
            }
        }

        private static bool RemoveOperator(DynamicType dt, SymbolId id) {
            OperatorMapping op;
            if (PythonExtensionTypeAttribute._pythonOperatorTable.TryGetValue(id, out op)) {
                DynamicTypeBuilder builder = DynamicTypeBuilder.GetBuilder(dt);
                if (op.IsUnary) {
                    builder.AddOperator(op.Operator, (UnaryOperator)null);
                }

                if (op.IsBinary) {
                    builder.AddOperator(op.Operator, (BinaryOperator)null);
                }

                if (op.IsTernary) {
                    builder.AddOperator(op.Operator, (TernaryOperator)null);
                }
                return true;
            }
            return false;
        }

        protected override DynamicTypeSlot CreateValueSlot(object value) {
            return new DynamicTypeUserDescriptorSlot(value);
        }

        private static object NewDict() {
            return new SymbolDictionary();
        }

        private void ValidateSupportedInheritance() {
            if (_type.GetInterface("ICustomMembers", false) == typeof(ICustomMembers)) {
                // ICustomAttributes is a well-known type. Ops.GetAttr etc first check for it, and dispatch to the
                // ICustomAttributes implementation. At the same time, built-in types like PythonModule, DynamicType, 
                // Super, SystemState, etc implement ICustomAttributes. If a user type inherits from these,
                // then Ops.GetAttr still dispatches to the ICustomAttributes implementation of the built-in types
                // instead of checking the user-type.
                if (_vars.ContainsKey(Symbols.GetAttribute))
                    throw new NotImplementedException("Overriding __getattribute__ of built-in types is not implemented");
                if (_vars.ContainsKey(Symbols.SetAttr))
                    throw new NotImplementedException("Overriding __setattr__ of built-in types is not implemented");
                if (_vars.ContainsKey(Symbols.DelAttr))
                    throw new NotImplementedException("Overriding __delattr__ of built-in types is not implemented");
            }

            // we don't support overriding __mro__
            if (_vars.ContainsKey(Symbols.MethodResolutionOrder))
                throw new NotImplementedException("Overriding __mro__ of built-in types is not implemented");

            // cannot override mro when inheriting from type
            if (_vars.ContainsKey(SymbolTable.StringToId("mro"))) {
                foreach (object o in _bases) {
                    DynamicType dt = o as DynamicType;
                    if (dt != null && dt.IsSubclassOf(TypeCache.DynamicType)) {
                        throw new NotImplementedException("Overriding type.mro is not implemented");
                    }
                }
            }
        }

        private void PopulateDefaultDictionary(IAttributesCollection fastDict) {
            if (!fastDict.ContainsKey(Symbols.Doc)) {
                fastDict[Symbols.Doc] = null;
            }

            if (HasWeakRef && !fastDict.ContainsKey(Symbols.WeakRef)) {
                fastDict[Symbols.WeakRef] = new DynamicTypeWeakRefSlot(this.Builder.UnfinishedType);
            }

            if (!fastDict.ContainsKey(Symbols.Dict) && HasDictionary) {
                fastDict[Symbols.Dict] = new DynamicTypeDictSlot();
            }
        }

        private bool HasWeakRef {
            get {
                return _hasWeakRef;   //!!!
            }
            set {
                _hasWeakRef = value;
            }
        }

        private bool HasSlots {
            get {
                return _hasSlots;
            }
            set {
                _hasSlots = value;
            }
        }

        private bool HasDictionary {
            get {
                return _hasDict;
            }
            set {
                _hasDict = value;
            }
        }

        private bool HasFinalizer {
            get {
                return _hasFinalizer;
            }
            set {
                _hasFinalizer = value;
            }
        }

        /// <summary>
        /// Set up the type
        /// </summary>
        /// <param name="context"></param>
        /// <param name="newBases"></param>
        /// <param name="newDict"></param>
        private bool InitializeUserType(CodeContext context, Tuple newBases, IAttributesCollection newDict) {
            newBases = EnsureBaseType(newBases);

            for (int i = 0; i < newBases.Count; i++) {
                for (int j = 0; j < newBases.Count; j++) {
                    if (i != j && newBases[i] == newBases[j]) {
                        OldClass oc = newBases[i] as OldClass;
                        if (oc != null) {
                            throw Ops.TypeError("duplicate base class {0}", oc.Name);
                        } else {
                            throw Ops.TypeError("duplicate base class {0}", ((DynamicType)newBases[i]).Name);
                        }
                    }
                }
            }

            List<DynamicType> newbs = new List<DynamicType>();
            TryGetMemberCustomizer baseCustomizer = null;
            SetMemberCustomizer setCustomizer = null;
            DeleteMemberCustomizer deleteCustomizer = null;
            bool mixedOldNew = false;
            foreach (object typeObj in newBases) {
                DynamicType dt = typeObj as DynamicType;
                if (dt == null) {
                    dt = ((OldClass)typeObj).TypeObject;
                    mixedOldNew = true;
                }

                newbs.Add(dt);
                baseCustomizer = baseCustomizer ?? dt.CustomBoundGetter;
                setCustomizer = setCustomizer ?? dt.CustomSetter;
                deleteCustomizer = deleteCustomizer ?? dt.CustomDeleter;
            }
            Builder.SetBases(newbs);
            Builder.SetResolutionOrder(Mro.Calculate(Builder.UnfinishedType, newbs));

            InitializeCustomAttributeAccess(newDict, baseCustomizer, setCustomizer, deleteCustomizer);

            if (mixedOldNew) {
                // if we have a mix of old-style & new style classes we need to add
                // every single operator that is available.  This will guarantee we can
                // do the lookup & hit the old-style class if it's there.
                AddAllOperators();
            }

            // if our dict, or any of our children, have a finalizer, then
            // we have a finalizer.
            bool hasFinalizer = newDict.ContainsKey(Symbols.Unassign);

            foreach (DynamicType baseTypeObj in Builder.UnfinishedType.BaseTypes) {
                if (baseTypeObj.IsSystemType) continue;

                DynamicTypeSlot dts;
                if (baseTypeObj.TryLookupSlot(context, Symbols.Unassign, out dts)) {
                    hasFinalizer = true;
                }
            }

            HasFinalizer = hasFinalizer;

            return mixedOldNew;
        }

        private void InitializeCustomAttributeAccess(IAttributesCollection newDict, TryGetMemberCustomizer baseCustomizer, SetMemberCustomizer setCustomizer, DeleteMemberCustomizer deleteCustomizer) {
            object value;
            if (newDict.TryGetValue(Symbols.GetAttribute, out value)) {
                CustomAttributeInfo info = new CustomAttributeInfo(value);
                Builder.SetCustomBoundGetter(info.HookedGetAttribute);
                newDict[Symbols.GetAttribute] = new DynamicTypeGetAttributeSlot(Builder.UnfinishedType, info, Symbols.GetAttribute);
            } else if (baseCustomizer != null) {
                Builder.SetCustomBoundGetter(baseCustomizer);
            }

            if (newDict.TryGetValue(Symbols.SetAttr, out value)) {
                CustomAttributeInfo info = new CustomAttributeInfo(value);
                Builder.SetCustomSetter(info.HookedSetAttribute);
                newDict[Symbols.SetAttr] = new DynamicTypeGetAttributeSlot(Builder.UnfinishedType, info, Symbols.SetAttr);
            } else if (setCustomizer != null) {
                Builder.SetCustomSetter(setCustomizer);
            }

            if (newDict.TryGetValue(Symbols.DelAttr, out value)) {
                CustomAttributeInfo info = new CustomAttributeInfo(value);
                Builder.SetCustomDeleter(info.HookedDeleteAttribute);
                newDict[Symbols.DelAttr] = new DynamicTypeGetAttributeSlot(Builder.UnfinishedType, info, Symbols.DelAttr);
            } else if (deleteCustomizer != null) {
                Builder.SetCustomDeleter(deleteCustomizer);
            }
        }

        protected static BinaryOperator MakeDefaultCall(DynamicType dt) {
            return delegate(CodeContext context, object self, object other, out object ret) {
                object value;
                if (!dt.TryGetBoundMember(context, self, Symbols.Call, out value)) {
                    ret = null;
                    return false;
                }

                //Console.WriteLine(value);

                if (other.GetType() == typeof(KwCallInfo)) {
                    KwCallInfo kwinfo = (KwCallInfo)other;
                    ret = Ops.CallWithKeywordArgs(context,
                        value,
                        kwinfo.Arguments,
                        kwinfo.Names);
                    return true;
                } else {
                    object[] arroth = (object[])other;
                    ret = Ops.CallWithContext(context,
                        value,
                        arroth);
                    return true;
                }
            }
            ;
        }

        private void AddAllOperators() {
            Dictionary<SymbolId, OperatorMapping> ops = PythonExtensionTypeAttribute._pythonOperatorTable;

            DynamicType dt = Builder.UnfinishedType;
            foreach (KeyValuePair<SymbolId, OperatorMapping> op in ops) {
                AddLookupOperator(Builder.UnfinishedType, op.Key);
            }
        }

        internal class CustomAttributeInfo {
            private object _func;

            public CustomAttributeInfo(object value) {
                _func = value;
            }

            public object Function {
                get { return _func; }
                set { _func = value; }
            }

            internal bool HookedGetAttribute(CodeContext context, object instance, SymbolId name, out object value) {
                try {
                    value = Ops.CallWithContext(context, _func, instance, SymbolTable.IdToString(name));
                    return true;
                } catch (MissingMemberException) {
                }
                value = null;
                return false;
            }

            internal void HookedSetAttribute(CodeContext context, object instance, SymbolId name, object value) {
                Ops.CallWithContext(context, _func, instance, name.ToString(), value);
            }

            internal void HookedDeleteAttribute(CodeContext context, object instance, SymbolId name) {
                Ops.CallWithContext(context, _func, instance, name.ToString());
            }
        }

        /// <summary>
        /// If we have only interfaces, we'll need to insert object's base
        /// </summary>
        private static Tuple EnsureBaseType(Tuple bases) {
            foreach (object baseClass in bases) {
                if (baseClass is OldClass) continue;

                DynamicType dt = baseClass as DynamicType;

                if (!dt.UnderlyingSystemType.IsInterface)
                    return bases;
            }

            // We found only interfaces. We need do add System.Object to the bases
            return new Tuple(bases, TypeCache.Object);
        }

    }
}
